[{"id":"dbf28d0c1562fa16371756c5d1c38cce","title":"2022年2月PragyanCTF比赛记录","content":"\n\n\nReverse\n考点\n\n\n\nOak\njava源代码，算法逆向\n\n\n\n\n\n\nOak\n题目描述\nJust little understanding of java would be enough Oak.class。\n\n\n\n\n源代码：\n  //\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\npublic class Oak &#123;\n    static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n\n    public Oak() &#123;\n    &#125;\n\n    public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n\n    public static int t(int var0) &#123;\n        int[] var1 = new int[var0 + 1];\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            var1[var2] = -1;\n        &#125;\n\n        return t_helper(var0, var1);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String[] var0= &#123;\"falg\"&#125;;\n        if (var0.length != 1) &#123;\n            System.out.println(\"Usage: [flag]\");\n        &#125; else &#123;\n            if (check(var0[0])) &#123;\n                System.out.println(\"Correct!\");\n            &#125; else &#123;\n                System.out.println(\"Incorrect\");\n            &#125;\n\n        &#125;\n    &#125;\n\n    public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n\n    public static boolean check(String var0) &#123;\n        long[] var1 = conv(var0);\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            if (data[var2] != (var1[var2] ^ (long)t(var2 * var2))) &#123;\n                return false;\n            &#125;\n        &#125;\n\n        return true;\n    &#125;\n&#125;\n\n解体思路：\nmain函数判断输入，要求输入一个flag，而且只能输入一个字符串\n\n\n\n加密后的数据存在了data里面\n static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n\n随后调用check函数\n public static boolean check(String var0) &#123;\n        long[] var1 = conv(var0);\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            if (data[var2] != (var1[var2] ^ (long)t(var2 * var2))) &#123;\n                return false;\n            &#125;\n        &#125;\n\n        return true;\n    &#125;\n 大致思路分两块，第一块将输入的flag传到conv函数变形，然后与t函数返回值进行异或操作，最后与data里的值判断是否相等\n\n所以先逆t函数：\n public static int t(int var0) &#123;\n    int[] var1 = new int[var0 + 1];\n    \n    for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n        var1[var2] = -1;\n    &#125;\n    \n    return t_helper(var0, var1);\n&#125;\n t函数又调用了t_helper函数\n public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n 看似复杂其实可以注意到传到t函数的值实际上是死的，分析它没有任何意义，逆向算法时直接照搬就行\n\n接着分析第一块：\n public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n 一开始的思路是从最后元素逆推回来，但是很麻烦，这里其实可以利用位运算的特性直接解，因为每个加密后的元素是先左移8位在加上后面那个未加密的元素，那么我们直接把前面八位置零就可以轻松获得后面一位的值用这种方法依次类推，flag就出来了\n\n\nexp编写：逆向思路大概是逆t→与data异或→所有元素除了后8位，其他位置零：\npublic class exp &#123;\n    static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n    public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n\n    public static int t(int var0) &#123;\n        int[] var1 = new int[var0 + 1];\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            var1[var2] = -1;\n        &#125;\n\n        return t_helper(var0, var1);\n    &#125;\n\n    public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n\n    public static void main(String[] args)&#123;\n        long[] var1 = new long[data.length];\n        for(int var2 = 0; var2 &lt; data.length; ++var2) &#123;\n            var1[var2] = (data[var2] ^ (long) t(var2 * var2));\n            System.out.print(var1[var2]);\n            System.out.print(\",\");\n        &#125;\n        \n\n        &#125;\n\n    &#125;\n\n前面的解密可以用题目的代码，后面置零就用python了：\nflag=\"\"\nrflag=[28767,24419,25460,29798,26235,31536,12402,29233,12647,26417,12654,28212,13436,31839,24430,28224,16461,19763,13101,11568,12390,26207,24394,18996,13430,30273,16735,24407,22369,24885,13663,24360,10281,10543,12124,23676,31804,15485,32112]\nfor i in range(39):\n    flag+=chr(rflag[i]&amp;127)\n\nt=(len(flag)-1)%len(flag)\nflag=flag[t:]+flag[:t]      //循环右移\nprint(flag)\n\np_ctf{0r1g1n4|n@M3-0f_J4vA_Wa5()&#x2F;|&lt;}\n","slug":"2022年2月PragyanCTF比赛记录","date":"2022-03-14T16:50:11.000Z","categories_index":"","tags_index":"比赛记录","author_index":"Big Devils"},{"id":"9c74912da0a2a9c3bea7b6b4717c1a49","title":"2022年2月SUSCTF比赛记录","content":"\n\n\nReverse\n考点\n\n\n\nDigitalCircuits\nexe→py，tea\n\n\n\n\n\n\nDigitalCircuitsexe→py:\n只要一看到这个图标就晓得大概率是py文件被打包成了exe，而且一般打包后的文件较大。直接用脚本解包。\npyinstxtractor.py DigitalCircuits.exe\n\n\n找到pyc文件之后在线网站反汇编就行\n算法分析：总体预览：反汇编后的代码为：\n#!/usr/bin/env python\n# visit https://tool.lu/pyc/ for more information\nimport time\n\ndef f1(a, b):\n    if a == '1' and b == '1':      //相当于，按位与操作\n        return '1'\n    return '0'\n\ndef f2(a, b):\n    if a == '0' and b == '0':     //相当于，按位或操作\n        return '0'\n    return '1'\n\ndef f3(a):                        //相当于，按位非操作\n    if a == '1':\n        return '0'\n    if a == '0':\n        return '1'\n\ndef f4(a, b):\n    return f2(f1(a, f3(b)), f1(f3(a), b))    //相当于，按位异或操作\n\ndef f5(x, y, z):\n    s = f4(f4(x, y), z)\n    c = f2(f1(x, y), f1(z, f2(x, y)))\n    return (s, c)\n\ndef f6(a, b):\n    ans = ''\n    z = '0'\n    a = a[::-1]\n    b = b[::-1]\n    for i in range(32):\n        ans += f5(a[i], b[i], z)[0]\n        z = f5(a[i], b[i], z)[1]\n\n    return ans[::-1]\n\ndef f7(a, n):                         //按位左移\n    return a[n:] + '0' * n\n\ndef f8(a, n):                         //按位右移\n    return n * '0' + a[:-n]\n\ndef f9(a, b):\n    ans = ''\n    for i in range(32):\n        ans += f4(a[i], b[i])\n\n    return ans\n\ndef f10(v0, v1, k0, k1, k2, k3):\n    s = '00000000000000000000000000000000'\n    d = '10011110001101110111100110111001'\n    for i in range(32):\n        s = f6(s, d)\n        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))\n        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))\n\n    return v0 + v1\n\nk0 = '0100010001000101'.zfill(32)    //zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。\nk1 = '0100000101000100'.zfill(32)\nk2 = '0100001001000101'.zfill(32)\nk3 = '0100010101000110'.zfill(32)\nflag = input('please input flag:')\nif flag[0:7] != 'SUSCTF&#123;' or flag[-1] != '&#125;':      //判断输入是否为SUSCTF&#123;&#125;包裹\n    print('Error!!!The formate of flag is SUSCTF&#123;XXX&#125;')\n    time.sleep(5)\n    exit(0)\nflagstr = flag[7:-1]\nif len(flagstr) != 24:                //实际flag长度为24\n    print('Error!!!The length of flag 24')\n    time.sleep(5)\n    exit(0)\nres = ''\nfor i in range(0, len(flagstr), 8):    //加密\n    v0 = flagstr[i:i + 4]\n    v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[i + 1]))[2:].zfill(8) + bin(ord(flagstr[i + 2]))[2:].zfill(8) + bin(ord(flagstr[i + 3]))[2:].zfill(8)\n    v1 = bin(ord(flagstr[i + 4]))[2:].zfill(8) + bin(ord(flagstr[i + 5]))[2:].zfill(8) + bin(ord(flagstr[i + 6]))[2:].zfill(8) + bin(ord(flagstr[i + 7]))[2:].zfill(8)\n    res += f10(v0, v1, k0, k1, k2, k3)\n\nif res == '001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111':\n    print('True')\nelse:\n    print('False')\ntime.sleep(5)\n\n这里的难点就是识别加密算法，前面之所以定义这么多函数就是掩盖其加密算法的特征，从函数走向分析每一个for的用处(看注释)，分析78行到82行的加密循环\n加密循环分析：for i in range(0, len(flagstr), 8):    //加密\n    v0 = flagstr[i:i + 4]\n    v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[i + 1]))[2:].zfill(8) + bin(ord(flagstr[i + 2]))[2:].zfill(8) + bin(ord(flagstr[i + 3]))[2:].zfill(8)\n    v1 = bin(ord(flagstr[i + 4]))[2:].zfill(8) + bin(ord(flagstr[i + 5]))[2:].zfill(8) + bin(ord(flagstr[i + 6]))[2:].zfill(8) + bin(ord(flagstr[i + 7]))[2:].zfill(8)\n    res += f10(v0, v1, k0, k1, k2, k3)\n\nbin函数特征\n\n每轮循环的v0都是flag的值，每次存4个元素\n通过bin函数以字符串的形式返回每个元素二进制表达形式\n但是bin函数会自作主张的在前面加上0b，所以通过[2:]来切片将0b去掉\n再通过zfill补充去掉的前两位\n\n\nfor循环一次做8个元素，前四个元素放在了放在v0，后四个元素放在v1\nv0和v1都是以字符串的形式保存这元素的二进制表达\n调用f10加密函数，参数为v0，v1和四个key\n\n这里分析一下特征：密钥为128位，明文总共64位，分成两个32位\n符合这个条件的为TEA加密算法。\n为了进一步确认，分析f10函数：\nf10()函数：(TEA加密函数)def f10(v0, v1, k0, k1, k2, k3):\n    s = '00000000000000000000000000000000'\n    d = '10011110001101110111100110111001'\n    for i in range(32):\n        s = f6(s, d)\n        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))\n        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))\n\n定义两个变量：分别为s和d，联想到TEA加密算法也是同样的做法(定义sum和detal两个变量)，delta变量放着的是黄黄金分割律数字转换的一个数字 2654435769 （0x9E3779B9）,但这个函数是用二进制的形式表达的计算机换算一下\n\n这里就可以锁定加密算法使用的是TEA了\n确认算法后就可以直接写解密脚本了：\ndef TeaDecode(enc,k):\n    v0 = enc[0]\n    v1 = enc[1]\n    n = (delta * 32) &amp; 0xFFFFFFFF\n    for i in range(32):\n        v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + n) ^ ((v0 >> 5) + k[3])\n        v1 &amp;= 0xFFFFFFFF\n        v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + n) ^ ((v1 >> 5) + k[1])\n        v0 &amp;= 0xFFFFFFFF\n        n -= delta\n    return (v0, v1)\n\nenflag = '001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111'\nenflag = [int(enflag[i:i + 32],2) for i in range(0, len(enflag), 32)]\n\nk = [0] * 4\nk[0] = int('0100010001000101'.zfill(32), 2)    #int(字符串或数字,进制(默认10进制))\nk[1] = int('0100000101000100'.zfill(32), 2)\nk[2] = int('0100001001000101'.zfill(32), 2)\nk[3] = int('0100010101000110'.zfill(32), 2)\ndelta = int('10011110001101110111100110111001', 2)\n\nflag = b''\nfor i in range(0,len(enflag),2):        #第三个参数为步进值\n    ans = TeaDecode(enflag[i:i + 2], k)\n    flag += ans[0].to_bytes(4, 'big') + ans[1].to_bytes(4, 'big')\n\nprint(b'SUSCTF&#123;' + flag + b'&#125;')\n\n","slug":"2022年2月SUSCTF比赛记录","date":"2022-03-14T13:33:40.000Z","categories_index":"","tags_index":"比赛记录","author_index":"Big Devils"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-03-14T09:34:34.870Z","categories_index":"","tags_index":"","author_index":"Big Devils"}]