[{"id":"0c474fb1f1d514e490492b4c7d30611c","title":"md5算法分析","content":"前言：MD5消息摘要算法(Message Digest Algorithm)，它对输入的任意长度的消息进行运算，产生一个128位的消息摘要。\n算法原理：1.数据填充：对原数据进行消息填充，使其长度取余512余448(448 mod 512)。换句话说就是填充后的数据长度比512的倍数小64位。并且这个数据填充是必做的操作，其实数据正好与448模512同余,也要填充。填充的动作是：附一个1在消息后面，然后用0来填充，直到消息的长度与448模512同余。至少填充1位，至多填充512位。\n2.添加长度：(这里和前面一步又呼应，多的448+64正好512)将上一步的结果附上64位的原数据长度，但如果要填充的原数据长度超过了2^64(本来就只有64字节给它放长度)则用原数据的低64位作为数据填充。(反正到这里得把数据弄到512的整数倍)\n3.初始化变量：用4个变量(A、B、C、D)计算消息摘要，这四个都是大小为32位的寄存器，这些寄存器根据下面的值进行初始化：\nA = 01234567h\nB = 89ABCDEFh\nC = FEDCBA98h\nD = 76543210h\n\nA = 0x67452301h\nB = 0xEFCDAB89h\nC = 0x98BADCFEh\nD = 0x10325476h\n\n4.数据处理：接着将处理后的数据以512位为一组进行运算，首先定义四个辅助函数，每个都是以3个32位双字作为输入，输出1个32位双字。\nF(X,Y,Z)=(X &amp; Y) | ((~X) &amp; Z);\nG(X,Y,Z)=(X &amp; Z) | (Y &amp; (~Z));\nH(X,Y,Z)=X ^ Y ^ Z;\nI(X,Y,Z)=Y ^ (X | (~Z));\n\nmd5逆向题实例\n","slug":"md5算法分析","date":"2022-03-15T01:45:46.000Z","categories_index":"","tags_index":"reverse常见算法","author_index":"Big Devils"},{"id":"dbf28d0c1562fa16371756c5d1c38cce","title":"2022年2月PragyanCTF比赛记录","content":"\n\n\nReverse\n考点\n\n\n\nOak\njava源代码，算法逆向\n\n\n\n\n\n\nOak\n题目描述\nJust little understanding of java would be enough Oak.class。\n\n\n\n\n源代码：\n  //\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\npublic class Oak &#123;\n    static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n\n    public Oak() &#123;\n    &#125;\n\n    public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n\n    public static int t(int var0) &#123;\n        int[] var1 = new int[var0 + 1];\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            var1[var2] = -1;\n        &#125;\n\n        return t_helper(var0, var1);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String[] var0= &#123;\"falg\"&#125;;\n        if (var0.length != 1) &#123;\n            System.out.println(\"Usage: [flag]\");\n        &#125; else &#123;\n            if (check(var0[0])) &#123;\n                System.out.println(\"Correct!\");\n            &#125; else &#123;\n                System.out.println(\"Incorrect\");\n            &#125;\n\n        &#125;\n    &#125;\n\n    public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n\n    public static boolean check(String var0) &#123;\n        long[] var1 = conv(var0);\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            if (data[var2] != (var1[var2] ^ (long)t(var2 * var2))) &#123;\n                return false;\n            &#125;\n        &#125;\n\n        return true;\n    &#125;\n&#125;\n\n解体思路：\nmain函数判断输入，要求输入一个flag，而且只能输入一个字符串\n\n\n\n加密后的数据存在了data里面\n static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n\n随后调用check函数\n public static boolean check(String var0) &#123;\n        long[] var1 = conv(var0);\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            if (data[var2] != (var1[var2] ^ (long)t(var2 * var2))) &#123;\n                return false;\n            &#125;\n        &#125;\n\n        return true;\n    &#125;\n 大致思路分两块，第一块将输入的flag传到conv函数变形，然后与t函数返回值进行异或操作，最后与data里的值判断是否相等\n\n所以先逆t函数：\n public static int t(int var0) &#123;\n    int[] var1 = new int[var0 + 1];\n    \n    for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n        var1[var2] = -1;\n    &#125;\n    \n    return t_helper(var0, var1);\n&#125;\n t函数又调用了t_helper函数\n public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n 看似复杂其实可以注意到传到t函数的值实际上是死的，分析它没有任何意义，逆向算法时直接照搬就行\n\n接着分析第一块：\n public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n 一开始的思路是从最后元素逆推回来，但是很麻烦，这里其实可以利用位运算的特性直接解，因为每个加密后的元素是先左移8位在加上后面那个未加密的元素，那么我们直接把前面八位置零就可以轻松获得后面一位的值用这种方法依次类推，flag就出来了\n\n\nexp编写：逆向思路大概是逆t→与data异或→所有元素除了后8位，其他位置零：\npublic class exp &#123;\n    static long[] data = new long[]&#123;28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L&#125;;\n    public static int t_helper(int var0, int[] var1) &#123;\n        if (var1[var0] != -1) &#123;\n            return var1[var0];\n        &#125; else if (var0 == 0) &#123;\n            var1[0] = 0;\n            return var1[0];\n        &#125; else if (var0 == 1) &#123;\n            var1[1] = 1;\n            return var1[1];\n        &#125; else if (var0 == 2) &#123;\n            var1[2] = 3;\n            return var1[2];\n        &#125; else &#123;\n            var1[var0] = 3 * t_helper(var0 - 1, var1) - 3 * t_helper(var0 - 2, var1) + t_helper(var0 - 3, var1);\n            return var1[var0];\n        &#125;\n    &#125;\n\n    public static int t(int var0) &#123;\n        int[] var1 = new int[var0 + 1];\n\n        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;\n            var1[var2] = -1;\n        &#125;\n\n        return t_helper(var0, var1);\n    &#125;\n\n    public static long[] conv(String var0) &#123;\n        long[] var1 = new long[var0.length()];\n\n        for(int var2 = 0; var2 &lt; var0.length(); ++var2) &#123;\n            var1[var2] = (long)((var0.charAt(var2) &lt;&lt; 8) + var0.charAt((var2 + 1) % var0.length()));\n        &#125;         //var1的各元素有falg字符串的当前元素左移8位和后面一个元素取余串长组成\n\n        return var1;\n    &#125;\n\n    public static void main(String[] args)&#123;\n        long[] var1 = new long[data.length];\n        for(int var2 = 0; var2 &lt; data.length; ++var2) &#123;\n            var1[var2] = (data[var2] ^ (long) t(var2 * var2));\n            System.out.print(var1[var2]);\n            System.out.print(\",\");\n        &#125;\n        \n\n        &#125;\n\n    &#125;\n\n前面的解密可以用题目的代码，后面置零就用python了：\nflag=\"\"\nrflag=[28767,24419,25460,29798,26235,31536,12402,29233,12647,26417,12654,28212,13436,31839,24430,28224,16461,19763,13101,11568,12390,26207,24394,18996,13430,30273,16735,24407,22369,24885,13663,24360,10281,10543,12124,23676,31804,15485,32112]\nfor i in range(39):\n    flag+=chr(rflag[i]&amp;127)\n\nt=(len(flag)-1)%len(flag)\nflag=flag[t:]+flag[:t]      //循环右移\nprint(flag)\n\np_ctf{0r1g1n4|n@M3-0f_J4vA_Wa5()&#x2F;|&lt;}\n","slug":"2022年2月PragyanCTF比赛记录","date":"2022-03-14T16:50:11.000Z","categories_index":"","tags_index":"比赛记录","author_index":"Big Devils"},{"id":"9c74912da0a2a9c3bea7b6b4717c1a49","title":"2022年2月SUSCTF比赛记录","content":"\n\n\nReverse\n考点\n\n\n\nDigitalCircuits\nexe→py，tea\n\n\n\n\n\n\nDigitalCircuitsexe→py:\n只要一看到这个图标就晓得大概率是py文件被打包成了exe，而且一般打包后的文件较大。直接用脚本解包。\npyinstxtractor.py DigitalCircuits.exe\n\n\n找到pyc文件之后在线网站反汇编就行\n算法分析：总体预览：反汇编后的代码为：\n#!/usr/bin/env python\n# visit https://tool.lu/pyc/ for more information\nimport time\n\ndef f1(a, b):\n    if a == '1' and b == '1':      //相当于，按位与操作\n        return '1'\n    return '0'\n\ndef f2(a, b):\n    if a == '0' and b == '0':     //相当于，按位或操作\n        return '0'\n    return '1'\n\ndef f3(a):                        //相当于，按位非操作\n    if a == '1':\n        return '0'\n    if a == '0':\n        return '1'\n\ndef f4(a, b):\n    return f2(f1(a, f3(b)), f1(f3(a), b))    //相当于，按位异或操作\n\ndef f5(x, y, z):\n    s = f4(f4(x, y), z)\n    c = f2(f1(x, y), f1(z, f2(x, y)))\n    return (s, c)\n\ndef f6(a, b):\n    ans = ''\n    z = '0'\n    a = a[::-1]\n    b = b[::-1]\n    for i in range(32):\n        ans += f5(a[i], b[i], z)[0]\n        z = f5(a[i], b[i], z)[1]\n\n    return ans[::-1]\n\ndef f7(a, n):                         //按位左移\n    return a[n:] + '0' * n\n\ndef f8(a, n):                         //按位右移\n    return n * '0' + a[:-n]\n\ndef f9(a, b):\n    ans = ''\n    for i in range(32):\n        ans += f4(a[i], b[i])\n\n    return ans\n\ndef f10(v0, v1, k0, k1, k2, k3):\n    s = '00000000000000000000000000000000'\n    d = '10011110001101110111100110111001'\n    for i in range(32):\n        s = f6(s, d)\n        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))\n        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))\n\n    return v0 + v1\n\nk0 = '0100010001000101'.zfill(32)    //zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。\nk1 = '0100000101000100'.zfill(32)\nk2 = '0100001001000101'.zfill(32)\nk3 = '0100010101000110'.zfill(32)\nflag = input('please input flag:')\nif flag[0:7] != 'SUSCTF&#123;' or flag[-1] != '&#125;':      //判断输入是否为SUSCTF&#123;&#125;包裹\n    print('Error!!!The formate of flag is SUSCTF&#123;XXX&#125;')\n    time.sleep(5)\n    exit(0)\nflagstr = flag[7:-1]\nif len(flagstr) != 24:                //实际flag长度为24\n    print('Error!!!The length of flag 24')\n    time.sleep(5)\n    exit(0)\nres = ''\nfor i in range(0, len(flagstr), 8):    //加密\n    v0 = flagstr[i:i + 4]\n    v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[i + 1]))[2:].zfill(8) + bin(ord(flagstr[i + 2]))[2:].zfill(8) + bin(ord(flagstr[i + 3]))[2:].zfill(8)\n    v1 = bin(ord(flagstr[i + 4]))[2:].zfill(8) + bin(ord(flagstr[i + 5]))[2:].zfill(8) + bin(ord(flagstr[i + 6]))[2:].zfill(8) + bin(ord(flagstr[i + 7]))[2:].zfill(8)\n    res += f10(v0, v1, k0, k1, k2, k3)\n\nif res == '001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111':\n    print('True')\nelse:\n    print('False')\ntime.sleep(5)\n\n这里的难点就是识别加密算法，前面之所以定义这么多函数就是掩盖其加密算法的特征，从函数走向分析每一个for的用处(看注释)，分析78行到82行的加密循环\n加密循环分析：for i in range(0, len(flagstr), 8):    //加密\n    v0 = flagstr[i:i + 4]\n    v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[i + 1]))[2:].zfill(8) + bin(ord(flagstr[i + 2]))[2:].zfill(8) + bin(ord(flagstr[i + 3]))[2:].zfill(8)\n    v1 = bin(ord(flagstr[i + 4]))[2:].zfill(8) + bin(ord(flagstr[i + 5]))[2:].zfill(8) + bin(ord(flagstr[i + 6]))[2:].zfill(8) + bin(ord(flagstr[i + 7]))[2:].zfill(8)\n    res += f10(v0, v1, k0, k1, k2, k3)\n\nbin函数特征\n\n每轮循环的v0都是flag的值，每次存4个元素\n通过bin函数以字符串的形式返回每个元素二进制表达形式\n但是bin函数会自作主张的在前面加上0b，所以通过[2:]来切片将0b去掉\n再通过zfill补充去掉的前两位\n\n\nfor循环一次做8个元素，前四个元素放在了放在v0，后四个元素放在v1\nv0和v1都是以字符串的形式保存这元素的二进制表达\n调用f10加密函数，参数为v0，v1和四个key\n\n这里分析一下特征：密钥为128位，明文总共64位，分成两个32位\n符合这个条件的为TEA加密算法。\n为了进一步确认，分析f10函数：\nf10()函数：(TEA加密函数)def f10(v0, v1, k0, k1, k2, k3):\n    s = '00000000000000000000000000000000'\n    d = '10011110001101110111100110111001'\n    for i in range(32):\n        s = f6(s, d)\n        v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))\n        v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))\n\n定义两个变量：分别为s和d，联想到TEA加密算法也是同样的做法(定义sum和detal两个变量)，delta变量放着的是黄黄金分割律数字转换的一个数字 2654435769 （0x9E3779B9）,但这个函数是用二进制的形式表达的计算机换算一下\n\n这里就可以锁定加密算法使用的是TEA了\n确认算法后就可以直接写解密脚本了：\ndef TeaDecode(enc,k):\n    v0 = enc[0]\n    v1 = enc[1]\n    n = (delta * 32) &amp; 0xFFFFFFFF\n    for i in range(32):\n        v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + n) ^ ((v0 >> 5) + k[3])\n        v1 &amp;= 0xFFFFFFFF\n        v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + n) ^ ((v1 >> 5) + k[1])\n        v0 &amp;= 0xFFFFFFFF\n        n -= delta\n    return (v0, v1)\n\nenflag = '001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111'\nenflag = [int(enflag[i:i + 32],2) for i in range(0, len(enflag), 32)]\n\nk = [0] * 4\nk[0] = int('0100010001000101'.zfill(32), 2)    #int(字符串或数字,进制(默认10进制))\nk[1] = int('0100000101000100'.zfill(32), 2)\nk[2] = int('0100001001000101'.zfill(32), 2)\nk[3] = int('0100010101000110'.zfill(32), 2)\ndelta = int('10011110001101110111100110111001', 2)\n\nflag = b''\nfor i in range(0,len(enflag),2):        #第三个参数为步进值\n    ans = TeaDecode(enflag[i:i + 2], k)\n    flag += ans[0].to_bytes(4, 'big') + ans[1].to_bytes(4, 'big')\n\nprint(b'SUSCTF&#123;' + flag + b'&#125;')\n\n","slug":"2022年2月SUSCTF比赛记录","date":"2022-03-14T13:33:40.000Z","categories_index":"","tags_index":"比赛记录","author_index":"Big Devils"},{"id":"4b1fbc501a26eea6619e2e89180a8452","title":"md5逆向题实例","content":"知识点：\n\n\nrtf文件\nhttps://magnificent-syrup-61f.notion.site/rtf-e2d961992a914f4eab37f3356db9e994\n\n\n\natoi&#x2F;itoa函数\nhttps://magnificent-syrup-61f.notion.site/atoi-itoa-a9be71db8a864e128429d4e826a1ec2d\n\n\npython的hashlib库\nhttps://magnificent-syrup-61f.notion.site/python-hashlib-0c3d02fa25e9444d88b9d5ed30d25eb0\n\n\n题解前期分析：\n无壳，32位\nida分析：主函数的代码：\nint __cdecl main_0(int argc, const char **argv, const char **envp)\n&#123;\n  DWORD v3; // eax\n  DWORD v4; // eax\n  char Str[260]; // [esp+4Ch] [ebp-310h] BYREF\n  int v7; // [esp+150h] [ebp-20Ch]\n  char String1[260]; // [esp+154h] [ebp-208h] BYREF\n  char Destination[260]; // [esp+258h] [ebp-104h] BYREF\n\n  memset(Destination, 0, sizeof(Destination));\n  memset(String1, 0, sizeof(String1));\n  v7 = 0;\n  printf(\"pls input the first passwd(1): \");\n  scanf(\"%s\", Destination);                 //输入第一个密码\n  if ( strlen(Destination) != 6 )             //密码长度为6\n  &#123;\n    printf(\"Must be 6 characters!\\\\n\");\n    ExitProcess(0);\n  &#125;\n  v7 = atoi(Destination);                    //将数字字符准换为整型数据\n  if ( v7 &lt; 100000 )\n    ExitProcess(0);\n  strcat(Destination, \"@DBApp\");             //在密码字符串后面加上@DBApp\n  v3 = strlen(Destination);\n  sub_40100A((BYTE *)Destination, v3, String1);      //跳入这个加密函数(这是解开密码1的关键函数)\n  if ( !_strcmpi(String1, \"6E32D0943418C2C33385BC35A1470250DD8923A9\") )  //经过函数加密后与\n  &#123;\n    printf(\"continue...\\\\n\\\\n\");\n    printf(\"pls input the first passwd(2): \");\n    memset(Str, 0, sizeof(Str));\n    scanf(\"%s\", Str);\n    if ( strlen(Str) != 6 )\n    &#123;\n      printf(\"Must be 6 characters!\\\\n\");\n      ExitProcess(0);\n    &#125;\n    strcat(Str, Destination);\n    memset(String1, 0, sizeof(String1));\n    v4 = strlen(Str);\n    sub_401019((BYTE *)Str, v4, String1);\n    if ( !_strcmpi(\"27019e688a4e62a649fd99cadaafdb4e\", String1) )\n    &#123;\n      if ( !(unsigned __int8)sub_40100F(Str) )\n      &#123;\n        printf(\"Error!!\\\\n\");\n        ExitProcess(0);\n      &#125;\n      printf(\"bye ~~\\\\n\");\n    &#125;\n  &#125;\n  return 0;\n&#125;\n\n程序大概就是两次的密码验证\n\n首先分析第一个加密函数：\nint __cdecl sub_401230(BYTE *pbData, DWORD dwDataLen, LPSTR lpString1)\n&#123;\n  int result; // eax\n  DWORD i; // [esp+4Ch] [ebp-28h]\n  CHAR String2[4]; // [esp+50h] [ebp-24h] BYREF\n  BYTE v6[20]; // [esp+54h] [ebp-20h] BYREF\n  DWORD pdwDataLen; // [esp+68h] [ebp-Ch] BYREF\n  HCRYPTHASH phHash; // [esp+6Ch] [ebp-8h] BYREF\n  HCRYPTPROV phProv; // [esp+70h] [ebp-4h] BYREF\n\n  if ( !CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) )\n    return 0;\n  if ( CryptCreateHash(phProv, 0x8004u, 0, 0, &amp;phHash) )\n  &#123;\n    if ( CryptHashData(phHash, pbData, dwDataLen, 0) )\n    &#123;\n      CryptGetHashParam(phHash, 2u, v6, &amp;pdwDataLen, 0);\n      *lpString1 = 0;\n      for ( i = 0; i &lt; pdwDataLen; ++i )\n      &#123;\n        wsprintfA(String2, \"%02X\", v6[i]);\n        lstrcatA(lpString1, String2);\n      &#125;\n      CryptDestroyHash(phHash);\n      CryptReleaseContext(phProv, 0);\n      result = 1;\n    &#125;\n    else\n    &#123;\n      CryptDestroyHash(phHash);\n      CryptReleaseContext(phProv, 0);\n      result = 0;\n    &#125;\n  &#125;\n  else\n  &#123;\n    CryptReleaseContext(phProv, 0);\n    result = 0;\n  &#125;\n  return result;\n&#125;\n\n粗略看一下被调用的函数指向的算法为单向散列算法hash。\n百度一下这些函数已经被弃用了，主要的函数是：\n\nCryptCreateHash( )\nBOOL CryptAcquireContextA(\n  [out] HCRYPTPROV *phProv,     \\\\\\\\通过调用 CryptAcquireContext创建的 CSP 的句柄。\n  [in]  LPCSTR     szProvider,  \\\\\\\\标识要使用的哈希算法的ALG_ID值(要使用哪种加密算法)\n  [in]  DWORD      dwProvType,  \\\\\\\\如果散列算法的类型是键控散列，例如基于散列的消息验证码(HMAC) 或消息验证码(MAC) 算法，则在此参数中传递散列的密钥。对于非键控算法，此参数必须设置为零。\n  [in]  DWORD      dwFlags      \\\\\\\\函数将句柄复制到新哈希对象的地址。使用完散列对象后，通过调用CryptDestroyHash函数释放句柄。\n);\n\n核心成员是第二个它标识着用到的算法是哪一个\n\nLPCSTR的ALG_ID：具体算法与数值对应关系\n\n\n\n通过特征码8004，确定散列算法为SHA1,思路基本确定为爆破枚举，而且已知密码的前6位有数字组成后面加上六个字符@DBApp 。\nexp为：\nimport hashlib\nrflag='6E32D0943418C2C33385BC35A1470250DD8923A9'.lower()\nstr1='@DBApp'\n\nfor i in range(100000,1000000):\n    flag=str(i)+str1            #需要用str将整型转成字符串,达到三者数据类型相匹配\n    obj=hashlib.sha1(flag.encode(\"utf-8\"))\n    flag=obj.hexdigest()\n    if flag==rflag:\n        print(i)\n\n'''\n这里有一点需要注意hashlib加密后的十六进制的字母是以小写的形式，\n所以上面的判断直接比较的话一定会找不到，需要用字符串操作“lower”方法\n将rflag字串的大写字符转小写\n'''\n\n解体方式：  得出第一轮的密码为：123321\n    跟进第二个函数还是hash，看特征码8003，是MD5。但这里遇到一个问题就是它没有规定这六个是什么字符，这要是爆破的话，难度大了许多，但是路见不平绕道而行，我们用别的办法：\n\n思路为在线网站解密hash\n  我们已经知道了hash值，可以考虑直接去在线网站解密，然后直接得出两个密码\n  \n  这样密码就都到手了：\n  密码1：123321\n  密码2：~!3a@0\n  分别输入这两个密码：\n  \n  同一目录下就会出现一个文件：\n  \n  打开就是flag\n\n\n\n","slug":"md5逆向题实例","date":"2022-03-15T02:48:39.000Z","categories_index":"","tags_index":"算法实例分析","author_index":"Big Devils"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-03-14T09:34:34.870Z","categories_index":"","tags_index":"","author_index":"Big Devils"}]